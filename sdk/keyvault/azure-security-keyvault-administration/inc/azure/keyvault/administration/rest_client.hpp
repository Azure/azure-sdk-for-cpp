
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
//
// Code generated by Microsoft (R) AutoRest C++ Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
#pragma once

#include <cstdint>
#include <map>
#include <memory>
#include <string>
#include <vector>

#include <azure/core/context.hpp>
#include <azure/core/datetime.hpp>
#include <azure/core/internal/http/pipeline.hpp>
#include <azure/core/nullable.hpp>
#include <azure/core/response.hpp>
#include <azure/core/url.hpp>
#include <azure/keyvault/administration/dll_import_export.hpp>

namespace Azure { namespace Security { namespace KeyVault { namespace Administration {
  /**
   * @brief Reflects the deletion recovery level currently in effect for secrets in the
   * current vault. If it contains 'Purgeable', the secret can be permanently deleted by a
   * privileged user; otherwise, only the system can purge the secret, at the end of the
   * retention interval.
   */
  class DeletionRecoveryLevel final {
  public:
    DeletionRecoveryLevel() = default;
    explicit DeletionRecoveryLevel(std::string value) : m_value(std::move(value)) {}
    bool operator==(const DeletionRecoveryLevel& other) const { return m_value == other.m_value; }
    bool operator!=(const DeletionRecoveryLevel& other) const { return !(*this == other); }
    const std::string& ToString() const { return m_value; }
    AZURE_SECURITY_KEYVAULT_ADMINISTRATION_DLLEXPORT const static DeletionRecoveryLevel Purgeable;
    AZURE_SECURITY_KEYVAULT_ADMINISTRATION_DLLEXPORT const static DeletionRecoveryLevel
        RecoverablePurgeable;
    AZURE_SECURITY_KEYVAULT_ADMINISTRATION_DLLEXPORT const static DeletionRecoveryLevel Recoverable;
    AZURE_SECURITY_KEYVAULT_ADMINISTRATION_DLLEXPORT const static DeletionRecoveryLevel
        RecoverableProtectedSubscription;
    AZURE_SECURITY_KEYVAULT_ADMINISTRATION_DLLEXPORT const static DeletionRecoveryLevel
        CustomizedRecoverablePurgeable;
    AZURE_SECURITY_KEYVAULT_ADMINISTRATION_DLLEXPORT const static DeletionRecoveryLevel
        CustomizedRecoverable;
    AZURE_SECURITY_KEYVAULT_ADMINISTRATION_DLLEXPORT const static DeletionRecoveryLevel
        CustomizedRecoverableProtectedSubscription;

  private:
    std::string m_value;
  };

  /**
   * @brief The secret management attributes.
   */
  struct SecretAttributes final
  {
    /**
     * SoftDelete data retention days. Value should be >=7 and <=90 when softDelete
     * enabled, otherwise 0.
     */
    int32_t recoverableDays = int32_t();
    /**
     * Reflects the deletion recovery level currently in effect for secrets in the current
     * vault. If it contains 'Purgeable', the secret can be permanently deleted by a
     * privileged user; otherwise, only the system can purge the secret, at the end of the
     * retention interval.
     */
    DeletionRecoveryLevel recoveryLevel;
  };

  /**
   * @brief The secret set parameters.
   */
  struct SecretSetParameters final
  {
    /**
     * The value of the secret.
     */
    std::string value;
    /**
     * Application specific metadata in the form of key-value pairs.
     */
    std::map<std::string, std::string> tags;
    /**
     * Type of the secret value such as a password.
     */
    Azure::Nullable<std::string> contentType;
    /**
     * The secret management attributes.
     */
    Azure::Nullable<SecretAttributes> secretAttributes;
  };

  struct SetSecretOptions final
  {
    SecretSetParameters parameters;
  };

  /**
   * @brief The secret update parameters.
   */
  struct SecretUpdateParameters final
  {
    /**
     * Type of the secret value such as a password.
     */
    std::string contentType;
    /**
     * The secret management attributes.
     */
    SecretAttributes secretAttributes;
    /**
     * Application specific metadata in the form of key-value pairs.
     */
    std::map<std::string, std::string> tags;
  };

  struct UpdateSecretOptions final
  {
    SecretUpdateParameters parameters;
  };

  /**
   * @brief The secret item containing secret metadata.
   */
  struct SecretItem final
  {
    /**
     * Secret identifier.
     */
    std::string id;
    /**
     * The secret management attributes.
     */
    SecretAttributes attributes;
    /**
     * Application specific metadata in the form of key-value pairs.
     */
    std::map<std::string, std::string> tags;
    /**
     * Type of the secret value such as a password.
     */
    std::string contentType;
    /**
     * True if the secret's lifetime is managed by key vault. If this is a key backing a
     * certificate, then managed will be true.
     */
    bool managed = bool();
  };

  struct GetSecretsOptions final
  {
    Azure::Nullable<int32_t> maxresults;
  };

  /**
   * @brief The secret list result.
   */
  struct SecretListResult final
  {
    /**
     * A response message containing a list of secrets in the key vault along with a link
     * to the next page of secrets.
     */
    std::vector<SecretItem> value;
    /**
     * The URL to get the next set of secrets.
     */
    std::string nextLink;
  };

  struct GetSecretVersionsOptions final
  {
    Azure::Nullable<int32_t> maxresults;
  };

  /**
   * @brief The deleted secret item containing metadata about the deleted secret.
   */
  struct DeletedSecretItem final
  {
    /**
     * The url of the recovery object, used to identify and recover the deleted secret.
     */
    std::string recoveryId;
    /**
     * The time when the secret is scheduled to be purged, in UTC.
     */
    Azure::DateTime scheduledPurgeDate;
    /**
     * The time when the secret was deleted, in UTC.
     */
    Azure::DateTime deletedDate;
  };

  /**
   * @brief The deleted secret list result.
   */
  struct DeletedSecretListResult final
  {
    /**
     * A response message containing a list of the deleted secrets in the vault along with
     * a link to the next page of deleted secrets.
     */
    std::vector<DeletedSecretItem> value;
    /**
     * The URL to get the next set of deleted secrets.
     */
    std::string nextLink;
  };

  struct GetDeletedSecretsOptions final
  {
    Azure::Nullable<int32_t> maxresults;
  };

  /**
   * @brief A Deleted Secret consisting of its previous id, attributes and its tags, as
   * well as information on when it will be purged.
   */
  struct DeletedSecretBundle final
  {
    /**
     * The url of the recovery object, used to identify and recover the deleted secret.
     */
    std::string recoveryId;
    /**
     * The time when the secret is scheduled to be purged, in UTC.
     */
    Azure::DateTime scheduledPurgeDate;
    /**
     * The time when the secret was deleted, in UTC.
     */
    Azure::DateTime deletedDate;
  };

  /**
   * @brief Response type for #null::Client::PurgeDeletedSecret.
   */
  struct PurgeDeletedSecretResult final
  {
  };

  /**
   * @brief The backup secret result, containing the backup blob.
   */
  struct BackupSecretResult final
  {
    /**
     * The backup blob containing the backed up secret.
     */
    std::vector<uint8_t> value;
  };

  /**
   * @brief The secret restore parameters.
   */
  struct SecretRestoreParameters final
  {
    /**
     * The backup blob associated with a secret bundle.
     */
    std::vector<uint8_t> secretBundleBackup;
  };

  /**
   * @brief A secret consisting of a value, id and its attributes.
   */
  struct SecretBundle final
  {
    /**
     * The secret value.
     */
    std::string value;
    /**
     * The secret id.
     */
    std::string id;
    /**
     * The content type of the secret.
     */
    std::string contentType;
    /**
     * The secret management attributes.
     */
    SecretAttributes attributes;
    /**
     * Application specific metadata in the form of key-value pairs.
     */
    std::map<std::string, std::string> tags;
    /**
     * If this is a secret backing a KV certificate, then this field specifies the
     * corresponding key backing the KV certificate.
     */
    std::string kid;
    /**
     * True if the secret's lifetime is managed by key vault. If this is a secret backing
     * a certificate, then managed will be true.
     */
    bool managed = bool();
  };

  struct RestoreSecretOptions final
  {
    SecretRestoreParameters parameters;
  };

  class Client final {
  private:
    std::shared_ptr<Azure::Core::Http::_internal::HttpPipeline> m_pipeline;
    Azure::Core::Url m_url;

  public:
    explicit Client(Azure::Core::Url url);

    Azure::Response<SecretBundle> SetSecret(
        const SetSecretOptions& options,
        const Azure::Core::Context& context = Azure::Core::Context{});

    Azure::Response<DeletedSecretBundle> DeleteSecret(
        const Azure::Core::Context& context = Azure::Core::Context{});

    Azure::Response<SecretBundle> UpdateSecret(
        const UpdateSecretOptions& options,
        const Azure::Core::Context& context = Azure::Core::Context{});

    Azure::Response<SecretBundle> GetSecret(
        const Azure::Core::Context& context = Azure::Core::Context{});

    Azure::Response<SecretListResult> GetSecrets(
        const GetSecretsOptions& options,
        const Azure::Core::Context& context = Azure::Core::Context{});

    Azure::Response<SecretListResult> GetSecretVersions(
        const GetSecretVersionsOptions& options,
        const Azure::Core::Context& context = Azure::Core::Context{});

    Azure::Response<DeletedSecretListResult> GetDeletedSecrets(
        const GetDeletedSecretsOptions& options,
        const Azure::Core::Context& context = Azure::Core::Context{});

    Azure::Response<DeletedSecretBundle> GetDeletedSecret(
        const Azure::Core::Context& context = Azure::Core::Context{});

    Azure::Response<PurgeDeletedSecretResult> PurgeDeletedSecret(
        const Azure::Core::Context& context = Azure::Core::Context{});

    Azure::Response<SecretBundle> RecoverDeletedSecret(
        const Azure::Core::Context& context = Azure::Core::Context{});

    Azure::Response<BackupSecretResult> BackupSecret(
        const Azure::Core::Context& context = Azure::Core::Context{});

    Azure::Response<SecretBundle> RestoreSecret(
        const RestoreSecretOptions& options,
        const Azure::Core::Context& context = Azure::Core::Context{});
  };

}}}} // namespace Azure::Security::KeyVault::Administration