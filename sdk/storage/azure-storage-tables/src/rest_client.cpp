// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

#include "azure/storage/tables/rest_client.hpp"

#include <azure/core/exception.hpp>
#include <azure/core/http/http.hpp>
#include <azure/core/http/http_status_code.hpp>
#include <azure/core/internal/environment.hpp>
#include <azure/core/internal/json/json.hpp>
#include <azure/core/io/body_stream.hpp>
#include <azure/storage/common/internal/xml_wrapper.hpp>
using namespace Azure::Storage::Tables;

AllowedMethodsType const AllowedMethodsType::Delete{"DELETE"};
AllowedMethodsType const AllowedMethodsType::Get{"GET"};
AllowedMethodsType const AllowedMethodsType::Head{"HEAD"};
AllowedMethodsType const AllowedMethodsType::Merge{"MERGE"};
AllowedMethodsType const AllowedMethodsType::Post{"POST"};
AllowedMethodsType const AllowedMethodsType::Options{"OPTIONS"};
AllowedMethodsType const AllowedMethodsType::Put{"PUT"};
AllowedMethodsType const AllowedMethodsType::Patch{"PATCH"};
AllowedMethodsType const AllowedMethodsType::Connect{"CONNECT"};
AllowedMethodsType const AllowedMethodsType::Trace{"TRACE"};

const TablesAudience TablesAudience::PublicAudience(
    Azure::Storage::_internal::TablesManagementScope);

Azure::Response<ListTableServices> TableServicesClient::List(
    ListOptions const& options,
    Core::Context const& context)
{
  auto url = m_url;
  url.AppendPath("subscriptions/");
  url.AppendPath(!m_subscriptionId.empty() ? Core::Url::Encode(m_subscriptionId) : "null");
  url.AppendPath("resourceGroups/");
  url.AppendPath(
      !options.ResourceGroupName.empty() ? Core::Url::Encode(options.ResourceGroupName) : "null");
  url.AppendPath("providers/Microsoft.Storage/storageAccounts/");
  url.AppendPath(!options.AccountName.empty() ? Core::Url::Encode(options.AccountName) : "null");
  url.AppendPath("tableServices");

  // url.SetQueryParameters({{"api-version",_detail::ApiVersion/*"2023-01-01"*/}});

  Core::Http::Request request(Core::Http::HttpMethod::Get, url);

  auto rawResponse = m_pipeline->Send(request, context);
  auto const httpStatusCode = rawResponse->GetStatusCode();

  if (httpStatusCode != Core::Http::HttpStatusCode::Ok)
  {
    throw Core::RequestFailedException(rawResponse);
  }

  ListTableServices response{};
  {
    auto const& responseBody = rawResponse->GetBody();
    if (responseBody.size() > 0)
    {
      auto const jsonRoot
          = Core::Json::_internal::json::parse(responseBody.begin(), responseBody.end());

      for (auto const& jsonItem : jsonRoot["value"])
      {
        TableServiceProperties vectorRootItem{};

        for (auto const& jsonRulesItem : jsonItem["properties"]["cors"]["corsRules"])
        {
          CorsRule vectorItem{};

          for (auto const& jsonSubItem : jsonRulesItem["allowedOrigins"])
          {
            std::string allowedOrigins{};

            allowedOrigins = jsonSubItem.get<std::string>();

            vectorItem.AllowedOrigins.emplace_back(std::move(allowedOrigins));
          }

          for (auto const& jsonSubItem : jsonRulesItem["allowedMethods"])
          {
            AllowedMethodsType allowedMethods{};

            allowedMethods = AllowedMethodsType(jsonSubItem.get<std::string>());

            vectorItem.AllowedMethods.emplace_back(std::move(allowedMethods));
          }

          vectorItem.MaxAgeInSeconds = jsonRulesItem["maxAgeInSeconds"].is_string()
              ? std::stoi(jsonRulesItem["maxAgeInSeconds"].get<std::string>())
              : jsonRulesItem["maxAgeInSeconds"].get<std::int32_t>();

          for (auto const& jsonSubItem : jsonRulesItem["exposedHeaders"])
          {
            std::string exposedHeaders{};

            exposedHeaders = jsonSubItem.get<std::string>();

            vectorItem.ExposedHeaders.emplace_back(std::move(exposedHeaders));
          }

          for (auto const& jsonSubItem : jsonRulesItem["allowedHeaders"])
          {
            std::string allowedHeaders{};

            allowedHeaders = jsonSubItem.get<std::string>();

            vectorItem.AllowedHeaders.emplace_back(std::move(allowedHeaders));
          }

          vectorRootItem.Properties.Cors.CorsRules.emplace_back(std::move(vectorItem));
        }

        response.Value.emplace_back(std::move(vectorRootItem));
      }
    }
  }

  return Response<ListTableServices>(std::move(response), std::move(rawResponse));
}

Azure::Response<Models::PreflightCheckResult> TableServicesClient::PreflightCheck(
    Models::PreflightCheckOptions const& options,
    Core::Context const& context)
{
  auto url = m_url;
  url.AppendPath(options.TableName);
  Core::Http::Request request(Core::Http::HttpMethod::Options, url);
  request.SetHeader("Origin", options.Origin);
  request.SetHeader("Access-Control-Request-Method", Core::Http::HttpMethod::Options.ToString());
  auto rawResponse = m_pipeline->Send(request, context);
  auto const httpStatusCode = rawResponse->GetStatusCode();

  if (httpStatusCode != Core::Http::HttpStatusCode::Ok)
  {
    throw Core::RequestFailedException(rawResponse);
  }

  Models::PreflightCheckResult response;

  return Response<Models::PreflightCheckResult>(std::move(response), std::move(rawResponse));
}
Azure::Response<Models::SetServicePropertiesResult> TableServicesClient::SetServiceProperties(
    Models::SetServicePropertiesOptions const& options,
    Core::Context const& context)
{
  std::string xmlBody;
  {
    _internal::XmlWriter writer;
    writer.Write(_internal::XmlNode{_internal::XmlNodeType::StartTag, "StorageServiceProperties"});
    writer.Write(_internal::XmlNode{_internal::XmlNodeType::StartTag, "Logging"});
    writer.Write(_internal::XmlNode{
        _internal::XmlNodeType::StartTag,
        "Version",
        options.TableServiceProperties.Logging.Version});
    writer.Write(_internal::XmlNode{
        _internal::XmlNodeType::StartTag,
        "Delete",
        options.TableServiceProperties.Logging.Delete ? "true" : "false"});
    writer.Write(_internal::XmlNode{
        _internal::XmlNodeType::StartTag,
        "Read",
        options.TableServiceProperties.Logging.Read ? "true" : "false"});
    writer.Write(_internal::XmlNode{
        _internal::XmlNodeType::StartTag,
        "Write",
        options.TableServiceProperties.Logging.Write ? "true" : "false"});
    writer.Write(_internal::XmlNode{_internal::XmlNodeType::StartTag, "RetentionPolicy"});
    writer.Write(_internal::XmlNode{
        _internal::XmlNodeType::StartTag,
        "Enabled",
        options.TableServiceProperties.Logging.RetentionPolicy.IsEnabled ? "true" : "false"});
    if (options.TableServiceProperties.Logging.RetentionPolicy.Days.HasValue())
    {
      writer.Write(_internal::XmlNode{
          _internal::XmlNodeType::StartTag,
          "Days",
          std::to_string(options.TableServiceProperties.Logging.RetentionPolicy.Days.Value())});
    }
    writer.Write(_internal::XmlNode{_internal::XmlNodeType::EndTag});
    writer.Write(_internal::XmlNode{_internal::XmlNodeType::EndTag});
    writer.Write(_internal::XmlNode{_internal::XmlNodeType::StartTag, "HourMetrics"});
    writer.Write(_internal::XmlNode{
        _internal::XmlNodeType::StartTag,
        "Version",
        options.TableServiceProperties.HourMetrics.Version});
    writer.Write(_internal::XmlNode{
        _internal::XmlNodeType::StartTag,
        "Enabled",
        options.TableServiceProperties.HourMetrics.IsEnabled ? "true" : "false"});
    if (options.TableServiceProperties.HourMetrics.IncludeApis.HasValue())
    {
      writer.Write(_internal::XmlNode{
          _internal::XmlNodeType::StartTag,
          "IncludeAPIs",
          options.TableServiceProperties.HourMetrics.IncludeApis.Value() ? "true" : "false"});
    }
    writer.Write(_internal::XmlNode{_internal::XmlNodeType::StartTag, "RetentionPolicy"});
    writer.Write(_internal::XmlNode{
        _internal::XmlNodeType::StartTag,
        "Enabled",
        options.TableServiceProperties.HourMetrics.RetentionPolicy.IsEnabled ? "true" : "false"});
    if (options.TableServiceProperties.HourMetrics.RetentionPolicy.Days.HasValue())
    {
      writer.Write(_internal::XmlNode{
          _internal::XmlNodeType::StartTag,
          "Days",
          std::to_string(options.TableServiceProperties.HourMetrics.RetentionPolicy.Days.Value())});
    }
    writer.Write(_internal::XmlNode{_internal::XmlNodeType::EndTag});
    writer.Write(_internal::XmlNode{_internal::XmlNodeType::EndTag});
    writer.Write(_internal::XmlNode{_internal::XmlNodeType::StartTag, "MinuteMetrics"});
    writer.Write(_internal::XmlNode{
        _internal::XmlNodeType::StartTag,
        "Version",
        options.TableServiceProperties.MinuteMetrics.Version});
    writer.Write(_internal::XmlNode{
        _internal::XmlNodeType::StartTag,
        "Enabled",
        options.TableServiceProperties.MinuteMetrics.IsEnabled ? "true" : "false"});
    if (options.TableServiceProperties.MinuteMetrics.IncludeApis.HasValue())
    {
      writer.Write(_internal::XmlNode{
          _internal::XmlNodeType::StartTag,
          "IncludeAPIs",
          options.TableServiceProperties.MinuteMetrics.IncludeApis.Value() ? "true" : "false"});
    }
    writer.Write(_internal::XmlNode{_internal::XmlNodeType::StartTag, "RetentionPolicy"});
    writer.Write(_internal::XmlNode{
        _internal::XmlNodeType::StartTag,
        "Enabled",
        options.TableServiceProperties.MinuteMetrics.RetentionPolicy.IsEnabled ? "true" : "false"});
    if (options.TableServiceProperties.MinuteMetrics.RetentionPolicy.Days.HasValue())
    {
      writer.Write(_internal::XmlNode{
          _internal::XmlNodeType::StartTag,
          "Days",
          std::to_string(
              options.TableServiceProperties.MinuteMetrics.RetentionPolicy.Days.Value())});
    }
    writer.Write(_internal::XmlNode{_internal::XmlNodeType::EndTag});
    writer.Write(_internal::XmlNode{_internal::XmlNodeType::EndTag});
    writer.Write(_internal::XmlNode{_internal::XmlNodeType::StartTag, "Cors"});
    for (const auto& i1 : options.TableServiceProperties.Cors)
    {
      writer.Write(_internal::XmlNode{_internal::XmlNodeType::StartTag, "CorsRule"});
      writer.Write(_internal::XmlNode{
          _internal::XmlNodeType::StartTag, "AllowedOrigins", i1.AllowedOrigins});
      writer.Write(_internal::XmlNode{
          _internal::XmlNodeType::StartTag, "AllowedMethods", i1.AllowedMethods});
      writer.Write(_internal::XmlNode{
          _internal::XmlNodeType::StartTag, "AllowedHeaders", i1.AllowedHeaders});
      writer.Write(_internal::XmlNode{
          _internal::XmlNodeType::StartTag, "ExposedHeaders", i1.ExposedHeaders});
      writer.Write(_internal::XmlNode{
          _internal::XmlNodeType::StartTag, "MaxAgeInSeconds", std::to_string(i1.MaxAgeInSeconds)});
      writer.Write(_internal::XmlNode{_internal::XmlNodeType::EndTag});
    }
    writer.Write(_internal::XmlNode{_internal::XmlNodeType::EndTag});
    writer.Write(_internal::XmlNode{_internal::XmlNodeType::EndTag});
    writer.Write(_internal::XmlNode{_internal::XmlNodeType::End});
    xmlBody = writer.GetDocument();
  }
  auto url = m_url;

  url.SetQueryParameters({{"restype", "service"}, {"comp", "properties"}});
  Core::IO::MemoryBodyStream requestBody(
      reinterpret_cast<std::uint8_t const*>(xmlBody.data()), xmlBody.length());

  Core::Http::Request request(Core::Http::HttpMethod::Put, url, &requestBody);

  request.SetHeader("Content-Type", "application/xml");
  request.SetHeader("Content-Length", std::to_string(requestBody.Length()));

  auto rawResponse = m_pipeline->Send(request, context);
  auto const httpStatusCode = rawResponse->GetStatusCode();

  if (httpStatusCode != Core::Http::HttpStatusCode::Accepted)
  {
    throw Core::RequestFailedException(rawResponse);
  }

  Models::SetServicePropertiesResult response;

  return Response<Models::SetServicePropertiesResult>(std::move(response), std::move(rawResponse));
}

Azure::Response<Models::TableServiceProperties> TableServicesClient::GetServiceProperties(
    Models::GetServicePropertiesOptions const& options,
    Core::Context const& context)
{
  (void)options;
  auto url = m_url;
  /* url.AppendPath("subscriptions/");
  url.AppendPath(!m_subscriptionId.empty() ? Core::Url::Encode(m_subscriptionId) : "null");
  url.AppendPath("resourceGroups/");
  url.AppendPath(
      !options.ResourceGroupName.empty() ? Core::Url::Encode(options.ResourceGroupName) : "null");
  url.AppendPath("providers/Microsoft.Storage/storageAccounts/");
  url.AppendPath(!options.AccountName.empty() ? Core::Url::Encode(options.AccountName) : "null");
  url.AppendPath("tableServices/");
  */
  // url.SetQueryParameters({{"api-version", "2023-01-01"}});
  url.SetQueryParameters({{"restype", "service"}, {"comp", "properties"}});

  Core::Http::Request request(Core::Http::HttpMethod::Get, url);

  auto pRawResponse = m_pipeline->Send(request, context);
  auto const httpStatusCode = pRawResponse->GetStatusCode();

  if (httpStatusCode != Core::Http::HttpStatusCode::Ok)
  {
    throw Core::RequestFailedException(pRawResponse);
  }

  Models::TableServiceProperties response{};
  {
    const auto& responseBody = pRawResponse->GetBody();
    _internal::XmlReader reader(
        reinterpret_cast<const char*>(responseBody.data()), responseBody.size());
    enum class XmlTagEnum
    {
      kUnknown,
      kStorageServiceProperties,
      kLogging,
      kVersion,
      kDelete,
      kRead,
      kWrite,
      kRetentionPolicy,
      kEnabled,
      kDays,
      kHourMetrics,
      kIncludeAPIs,
      kMinuteMetrics,
      kCors,
      kCorsRule,
      kAllowedOrigins,
      kAllowedMethods,
      kAllowedHeaders,
      kExposedHeaders,
      kMaxAgeInSeconds,
    };
    const std::unordered_map<std::string, XmlTagEnum> XmlTagEnumMap{
        {"StorageServiceProperties", XmlTagEnum::kStorageServiceProperties},
        {"Logging", XmlTagEnum::kLogging},
        {"Version", XmlTagEnum::kVersion},
        {"Delete", XmlTagEnum::kDelete},
        {"Read", XmlTagEnum::kRead},
        {"Write", XmlTagEnum::kWrite},
        {"RetentionPolicy", XmlTagEnum::kRetentionPolicy},
        {"Enabled", XmlTagEnum::kEnabled},
        {"Days", XmlTagEnum::kDays},
        {"HourMetrics", XmlTagEnum::kHourMetrics},
        {"IncludeAPIs", XmlTagEnum::kIncludeAPIs},
        {"MinuteMetrics", XmlTagEnum::kMinuteMetrics},
        {"Cors", XmlTagEnum::kCors},
        {"CorsRule", XmlTagEnum::kCorsRule},
        {"AllowedOrigins", XmlTagEnum::kAllowedOrigins},
        {"AllowedMethods", XmlTagEnum::kAllowedMethods},
        {"AllowedHeaders", XmlTagEnum::kAllowedHeaders},
        {"ExposedHeaders", XmlTagEnum::kExposedHeaders},
        {"MaxAgeInSeconds", XmlTagEnum::kMaxAgeInSeconds},
    };
    std::vector<XmlTagEnum> xmlPath;
    Models::CorsRule vectorElement1;
    while (true)
    {
      auto node = reader.Read();
      if (node.Type == _internal::XmlNodeType::End)
      {
        break;
      }
      else if (node.Type == _internal::XmlNodeType::StartTag)
      {
        auto ite = XmlTagEnumMap.find(node.Name);
        xmlPath.push_back(ite == XmlTagEnumMap.end() ? XmlTagEnum::kUnknown : ite->second);
      }
      else if (node.Type == _internal::XmlNodeType::Text)
      {
        if (xmlPath.size() == 3 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kLogging && xmlPath[2] == XmlTagEnum::kVersion)
        {
          response.Logging.Version = node.Value;
        }
        else if (
            xmlPath.size() == 3 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kLogging && xmlPath[2] == XmlTagEnum::kDelete)
        {
          response.Logging.Delete = node.Value == std::string("true");
        }
        else if (
            xmlPath.size() == 3 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kLogging && xmlPath[2] == XmlTagEnum::kRead)
        {
          response.Logging.Read = node.Value == std::string("true");
        }
        else if (
            xmlPath.size() == 3 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kLogging && xmlPath[2] == XmlTagEnum::kWrite)
        {
          response.Logging.Write = node.Value == std::string("true");
        }
        else if (
            xmlPath.size() == 4 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kLogging && xmlPath[2] == XmlTagEnum::kRetentionPolicy
            && xmlPath[3] == XmlTagEnum::kEnabled)
        {
          response.Logging.RetentionPolicy.IsEnabled = node.Value == std::string("true");
        }
        else if (
            xmlPath.size() == 4 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kLogging && xmlPath[2] == XmlTagEnum::kRetentionPolicy
            && xmlPath[3] == XmlTagEnum::kDays)
        {
          response.Logging.RetentionPolicy.Days = std::stoi(node.Value);
        }
        else if (
            xmlPath.size() == 3 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kHourMetrics && xmlPath[2] == XmlTagEnum::kVersion)
        {
          response.HourMetrics.Version = node.Value;
        }
        else if (
            xmlPath.size() == 3 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kHourMetrics && xmlPath[2] == XmlTagEnum::kEnabled)
        {
          response.HourMetrics.IsEnabled = node.Value == std::string("true");
        }
        else if (
            xmlPath.size() == 3 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kHourMetrics && xmlPath[2] == XmlTagEnum::kIncludeAPIs)
        {
          response.HourMetrics.IncludeApis = node.Value == std::string("true");
        }
        else if (
            xmlPath.size() == 4 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kHourMetrics && xmlPath[2] == XmlTagEnum::kRetentionPolicy
            && xmlPath[3] == XmlTagEnum::kEnabled)
        {
          response.HourMetrics.RetentionPolicy.IsEnabled = node.Value == std::string("true");
        }
        else if (
            xmlPath.size() == 4 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kHourMetrics && xmlPath[2] == XmlTagEnum::kRetentionPolicy
            && xmlPath[3] == XmlTagEnum::kDays)
        {
          response.HourMetrics.RetentionPolicy.Days = std::stoi(node.Value);
        }
        else if (
            xmlPath.size() == 3 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kMinuteMetrics && xmlPath[2] == XmlTagEnum::kVersion)
        {
          response.MinuteMetrics.Version = node.Value;
        }
        else if (
            xmlPath.size() == 3 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kMinuteMetrics && xmlPath[2] == XmlTagEnum::kEnabled)
        {
          response.MinuteMetrics.IsEnabled = node.Value == std::string("true");
        }
        else if (
            xmlPath.size() == 3 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kMinuteMetrics && xmlPath[2] == XmlTagEnum::kIncludeAPIs)
        {
          response.MinuteMetrics.IncludeApis = node.Value == std::string("true");
        }
        else if (
            xmlPath.size() == 4 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kMinuteMetrics
            && xmlPath[2] == XmlTagEnum::kRetentionPolicy && xmlPath[3] == XmlTagEnum::kEnabled)
        {
          response.MinuteMetrics.RetentionPolicy.IsEnabled = node.Value == std::string("true");
        }
        else if (
            xmlPath.size() == 4 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kMinuteMetrics
            && xmlPath[2] == XmlTagEnum::kRetentionPolicy && xmlPath[3] == XmlTagEnum::kDays)
        {
          response.MinuteMetrics.RetentionPolicy.Days = std::stoi(node.Value);
        }
        else if (
            xmlPath.size() == 4 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kCors && xmlPath[2] == XmlTagEnum::kCorsRule
            && xmlPath[3] == XmlTagEnum::kAllowedOrigins)
        {
          vectorElement1.AllowedOrigins = node.Value;
        }
        else if (
            xmlPath.size() == 4 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kCors && xmlPath[2] == XmlTagEnum::kCorsRule
            && xmlPath[3] == XmlTagEnum::kAllowedMethods)
        {
          vectorElement1.AllowedMethods = node.Value;
        }
        else if (
            xmlPath.size() == 4 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kCors && xmlPath[2] == XmlTagEnum::kCorsRule
            && xmlPath[3] == XmlTagEnum::kAllowedHeaders)
        {
          vectorElement1.AllowedHeaders = node.Value;
        }
        else if (
            xmlPath.size() == 4 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kCors && xmlPath[2] == XmlTagEnum::kCorsRule
            && xmlPath[3] == XmlTagEnum::kExposedHeaders)
        {
          vectorElement1.ExposedHeaders = node.Value;
        }
        else if (
            xmlPath.size() == 4 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kCors && xmlPath[2] == XmlTagEnum::kCorsRule
            && xmlPath[3] == XmlTagEnum::kMaxAgeInSeconds)
        {
          vectorElement1.MaxAgeInSeconds = std::stoi(node.Value);
        }
      }
      else if (node.Type == _internal::XmlNodeType::Attribute)
      {
      }
      else if (node.Type == _internal::XmlNodeType::EndTag)
      {
        if (xmlPath.size() == 3 && xmlPath[0] == XmlTagEnum::kStorageServiceProperties
            && xmlPath[1] == XmlTagEnum::kCors && xmlPath[2] == XmlTagEnum::kCorsRule)
        {
          response.Cors.push_back(std::move(vectorElement1));
          vectorElement1 = Models::CorsRule();
        }
        xmlPath.pop_back();
      }
    }
  }
  return Response<Models::TableServiceProperties>(std::move(response), std::move(pRawResponse));
}


Azure::Response<Models::ServiceStatistics> TableServicesClient::GetStatistics(
    Models::GetServiceStatisticsOptions const& options,
    const Core::Context& context)
{
  (void)options;
  auto url = m_url;
  std::string host = url.GetHost();
  std::string accountName = host.substr(0, host.find('.'));
  accountName += "-secondary";
  url.SetHost(accountName + "." + host.substr(host.find('.') + 1));
  url.SetQueryParameters({{"restype", "service"}, {"comp", "stats"}});
  Core::Http::Request request(Core::Http::HttpMethod::Get, url);

  auto pRawResponse = m_pipeline->Send(request, context);
  auto httpStatusCode = pRawResponse->GetStatusCode();
  if (httpStatusCode != Core::Http::HttpStatusCode::Ok)
  {
    throw Core::RequestFailedException(pRawResponse);
  }
  Models::ServiceStatistics response;
  {
    const auto& responseBody = pRawResponse->GetBody();
    _internal::XmlReader reader(
        reinterpret_cast<const char*>(responseBody.data()), responseBody.size());
    enum class XmlTagEnum
    {
      kUnknown,
      kStorageServiceStats,
      kGeoReplication,
      kStatus,
      kLastSyncTime,
    };
    const std::unordered_map<std::string, XmlTagEnum> XmlTagEnumMap{
        {"StorageServiceStats", XmlTagEnum::kStorageServiceStats},
        {"GeoReplication", XmlTagEnum::kGeoReplication},
        {"Status", XmlTagEnum::kStatus},
        {"LastSyncTime", XmlTagEnum::kLastSyncTime},
    };
    std::vector<XmlTagEnum> xmlPath;

    while (true)
    {
      auto node = reader.Read();
      if (node.Type == _internal::XmlNodeType::End)
      {
        break;
      }
      else if (node.Type == _internal::XmlNodeType::StartTag)
      {
        auto ite = XmlTagEnumMap.find(node.Name);
        xmlPath.push_back(ite == XmlTagEnumMap.end() ? XmlTagEnum::kUnknown : ite->second);
      }
      else if (node.Type == _internal::XmlNodeType::Text)
      {
        if (xmlPath.size() == 3 && xmlPath[0] == XmlTagEnum::kStorageServiceStats
            && xmlPath[1] == XmlTagEnum::kGeoReplication && xmlPath[2] == XmlTagEnum::kStatus)
        {
          response.GeoReplication.Status = Models::GeoReplicationStatus(node.Value);
        }
        else if (
            xmlPath.size() == 3 && xmlPath[0] == XmlTagEnum::kStorageServiceStats
            && xmlPath[1] == XmlTagEnum::kGeoReplication && xmlPath[2] == XmlTagEnum::kLastSyncTime)
        {
          response.GeoReplication.LastSyncedOn
              = DateTime::Parse(node.Value, Azure::DateTime::DateFormat::Rfc1123);
        }
      }
      else if (node.Type == _internal::XmlNodeType::Attribute)
      {
      }
      else if (node.Type == _internal::XmlNodeType::EndTag)
      {

        xmlPath.pop_back();
      }
    }
  }
  return Response<Models::ServiceStatistics>(std::move(response), std::move(pRawResponse));
}

TableClient::TableClient(std::string subscriptionId)
    : m_pipeline(new Core::Http::_internal::HttpPipeline({}, "storage-tables", "", {}, {})),
      m_url("https://management.azure.com"), m_subscriptionId(std::move(subscriptionId))
{
}

Azure::Response<Models::Table> TableClient::Create(
    Core::Context const& context)
{
  auto url = m_url;
  url.AppendPath("Tables");
  /* url.AppendPath("subscriptions/");
  url.AppendPath(!m_subscriptionId.empty() ? Core::Url::Encode(m_subscriptionId) : "null");
  url.AppendPath("resourceGroups/");
  url.AppendPath(
      !options.ResourceGroupName.empty() ? Core::Url::Encode(options.ResourceGroupName) : "null");
  url.AppendPath("providers/Microsoft.Storage/storageAccounts/");
  url.AppendPath(!options.AccountName.empty() ? Core::Url::Encode(options.AccountName) : "null");
  url.AppendPath("tableServices/default/tables/");
  url.AppendPath(!options.TableName.empty() ? Core::Url::Encode(options.TableName) : "null");

  url.SetQueryParameters({{"api-version", "2023-01-01"}});
  */
  std::string jsonBody;
  {
    auto jsonRoot = Core::Json::_internal::json::object();

    jsonRoot["TableName"] = m_tableName;
    jsonBody = jsonRoot.dump();
  }

  Core::IO::MemoryBodyStream requestBody(
      reinterpret_cast<std::uint8_t const*>(jsonBody.data()), jsonBody.length());

  Core::Http::Request request(Core::Http::HttpMethod::Post, url, &requestBody);

  request.SetHeader("Content-Type", "application/json");
  request.SetHeader("Content-Length", std::to_string(requestBody.Length()));
  request.SetHeader("Accept", "application/json;odata=fullmetadata");
  auto rawResponse = m_pipeline->Send(request, context);
  auto const httpStatusCode = rawResponse->GetStatusCode();

  if (httpStatusCode != Core::Http::HttpStatusCode::Created)
  {
    throw Core::RequestFailedException(rawResponse);
  }

  Models::Table response{};
  {
    auto const& responseBody = rawResponse->GetBody();
    std::string responseString = std::string(responseBody.begin(), responseBody.end());
    if (responseBody.size() > 0)
    {
      auto const jsonRoot
          = Core::Json::_internal::json::parse(responseBody.begin(), responseBody.end());

      response.TableName = jsonRoot["TableName"].get<std::string>();
      response.EditLink = jsonRoot["odata.editLink"].get<std::string>();
      response.Id = jsonRoot["odata.id"].get<std::string>();
      response.Metadata = jsonRoot["odata.metadata"].get<std::string>();
      response.Type = jsonRoot["odata.type"].get<std::string>();
    }
  }

  return Response<Models::Table>(std::move(response), std::move(rawResponse));
}

Azure::Response<Table> TableClient::Update(
    UpdateOptions const& options,
    Core::Context const& context)
{
  auto url = m_url;
  url.AppendPath("subscriptions/");
  url.AppendPath(!m_subscriptionId.empty() ? Core::Url::Encode(m_subscriptionId) : "null");
  url.AppendPath("resourceGroups/");
  url.AppendPath(
      !options.ResourceGroupName.empty() ? Core::Url::Encode(options.ResourceGroupName) : "null");
  url.AppendPath("providers/Microsoft.Storage/storageAccounts/");
  url.AppendPath(!options.AccountName.empty() ? Core::Url::Encode(options.AccountName) : "null");
  url.AppendPath("tableServices/default/tables/");
  url.AppendPath(!options.TableName.empty() ? Core::Url::Encode(options.TableName) : "null");

  url.SetQueryParameters({{"api-version", "2023-01-01"}});

  std::string jsonBody;
  {
    auto jsonRoot = Core::Json::_internal::json::object();

    jsonRoot["properties"]["tableName"] = options.Parameters.Properties.TableName;
    jsonRoot["properties"]["signedIdentifiers"] = Core::Json::_internal::json::array();

    for (std::size_t i = 0; i < options.Parameters.Properties.SignedIdentifiers.size(); ++i)
    {
      jsonRoot["properties"]["signedIdentifiers"][i]["id"]
          = options.Parameters.Properties.SignedIdentifiers[i].Id;

      if (options.Parameters.Properties.SignedIdentifiers[i].AccessPolicy.StartTime.HasValue())
      {
        jsonRoot["properties"]["signedIdentifiers"][i]["accessPolicy"]["startTime"]
            = options.Parameters.Properties.SignedIdentifiers[i]
                  .AccessPolicy.StartTime.Value()
                  .ToString();
      }

      if (options.Parameters.Properties.SignedIdentifiers[i].AccessPolicy.ExpiryTime.HasValue())
      {
        jsonRoot["properties"]["signedIdentifiers"][i]["accessPolicy"]["expiryTime"]
            = options.Parameters.Properties.SignedIdentifiers[i]
                  .AccessPolicy.ExpiryTime.Value()
                  .ToString();
      }

      jsonRoot["properties"]["signedIdentifiers"][i]["accessPolicy"]["permission"]
          = options.Parameters.Properties.SignedIdentifiers[i].AccessPolicy.Permission;
    }

    jsonBody = jsonRoot.dump();
  }

  Core::IO::MemoryBodyStream requestBody(
      reinterpret_cast<std::uint8_t const*>(jsonBody.data()), jsonBody.length());

  Core::Http::Request request(Core::Http::HttpMethod::Patch, url, &requestBody);

  request.SetHeader("Content-Type", "application/json");
  request.SetHeader("Content-Length", std::to_string(requestBody.Length()));

  auto rawResponse = m_pipeline->Send(request, context);
  auto const httpStatusCode = rawResponse->GetStatusCode();

  if (httpStatusCode != Core::Http::HttpStatusCode::Ok)
  {
    throw Core::RequestFailedException(rawResponse);
  }

  Table response{};
  {
    auto const& responseBody = rawResponse->GetBody();
    if (responseBody.size() > 0)
    {
      auto const jsonRoot
          = Core::Json::_internal::json::parse(responseBody.begin(), responseBody.end());

      response.Properties.TableName = jsonRoot["properties"]["tableName"].get<std::string>();
      if (jsonRoot["properties"].contains("signedIdentifiers"))
      {
        for (auto const& jsonItem : jsonRoot["properties"]["signedIdentifiers"])
        {
          TableSignedIdentifier vectorItem{};

          vectorItem.Id = jsonItem["id"].get<std::string>();

          if (jsonItem.contains("startTime"))
          {
            vectorItem.AccessPolicy.StartTime = DateTime::Parse(
                jsonItem["startTime"].get<std::string>(), DateTime::DateFormat::Rfc3339);
          }

          if (jsonItem.contains("expiryTime"))
          {
            vectorItem.AccessPolicy.ExpiryTime = DateTime::Parse(
                jsonItem["expiryTime"].get<std::string>(), DateTime::DateFormat::Rfc3339);
          }

          vectorItem.AccessPolicy.Permission = jsonItem["permission"].get<std::string>();

          response.Properties.SignedIdentifiers.emplace_back(std::move(vectorItem));
        }
      }
    }
  }

  return Response<Table>(std::move(response), std::move(rawResponse));
}

Azure::Response<Table> TableClient::Get(GetOptions const& options, Core::Context const& context)
{
  auto url = m_url;
  url.AppendPath("subscriptions/");
  url.AppendPath(!m_subscriptionId.empty() ? Core::Url::Encode(m_subscriptionId) : "null");
  url.AppendPath("resourceGroups/");
  url.AppendPath(
      !options.ResourceGroupName.empty() ? Core::Url::Encode(options.ResourceGroupName) : "null");
  url.AppendPath("providers/Microsoft.Storage/storageAccounts/");
  url.AppendPath(!options.AccountName.empty() ? Core::Url::Encode(options.AccountName) : "null");
  url.AppendPath("tableServices/default/tables/");
  url.AppendPath(!options.TableName.empty() ? Core::Url::Encode(options.TableName) : "null");

  url.SetQueryParameters({{"api-version", "2023-01-01"}});

  Core::Http::Request request(Core::Http::HttpMethod::Get, url);

  auto rawResponse = m_pipeline->Send(request, context);
  auto const httpStatusCode = rawResponse->GetStatusCode();

  if (httpStatusCode != Core::Http::HttpStatusCode::Ok)
  {
    throw Core::RequestFailedException(rawResponse);
  }

  Table response{};
  {
    auto const& responseBody = rawResponse->GetBody();
    std::string responseString = std::string(responseBody.begin(), responseBody.end());
    if (responseBody.size() > 0)
    {
      auto const jsonRoot
          = Core::Json::_internal::json::parse(responseBody.begin(), responseBody.end());

      response.Properties.TableName = jsonRoot["properties"]["tableName"].get<std::string>();
      if (jsonRoot["properties"].contains("signedIdentifiers"))
      {
        for (auto const& jsonItem : jsonRoot["properties"]["signedIdentifiers"])
        {
          TableSignedIdentifier vectorItem{};

          vectorItem.Id = jsonItem["id"].get<std::string>();

          if (jsonItem.contains("startTime"))
          {
            vectorItem.AccessPolicy.StartTime = DateTime::Parse(
                jsonItem["startTime"].get<std::string>(), DateTime::DateFormat::Rfc3339);
          }

          if (jsonItem.contains("expiryTime"))
          {
            vectorItem.AccessPolicy.ExpiryTime = DateTime::Parse(
                jsonItem["expiryTime"].get<std::string>(), DateTime::DateFormat::Rfc3339);
          }

          vectorItem.AccessPolicy.Permission = jsonItem["permission"].get<std::string>();

          response.Properties.SignedIdentifiers.emplace_back(std::move(vectorItem));
        }
      }
    }
  }

  return Response<Table>(std::move(response), std::move(rawResponse));
}

Azure::Response<DeleteResult> TableClient::Delete(
    DeleteOptions const& options,
    Core::Context const& context)
{
  auto url = m_url;
  url.AppendPath("subscriptions/");
  url.AppendPath(!m_subscriptionId.empty() ? Core::Url::Encode(m_subscriptionId) : "null");
  url.AppendPath("resourceGroups/");
  url.AppendPath(
      !options.ResourceGroupName.empty() ? Core::Url::Encode(options.ResourceGroupName) : "null");
  url.AppendPath("providers/Microsoft.Storage/storageAccounts/");
  url.AppendPath(!options.AccountName.empty() ? Core::Url::Encode(options.AccountName) : "null");
  url.AppendPath("tableServices/default/tables/");
  url.AppendPath(!options.TableName.empty() ? Core::Url::Encode(options.TableName) : "null");

  url.SetQueryParameters({{"api-version", "2023-01-01"}});

  Core::Http::Request request(Core::Http::HttpMethod::Delete, url);

  auto rawResponse = m_pipeline->Send(request, context);
  auto const httpStatusCode = rawResponse->GetStatusCode();

  if (httpStatusCode != Core::Http::HttpStatusCode::NoContent)
  {
    throw Core::RequestFailedException(rawResponse);
  }

  DeleteResult response{};

  return Response<DeleteResult>(std::move(response), std::move(rawResponse));
}

Azure::Response<ListTableResource> TableClient::List(
    ListOptions const& options,
    Core::Context const& context)
{
  auto url = m_url;
  url.AppendPath("subscriptions/");
  url.AppendPath(!m_subscriptionId.empty() ? Core::Url::Encode(m_subscriptionId) : "null");
  url.AppendPath("resourceGroups/");
  url.AppendPath(
      !options.ResourceGroupName.empty() ? Core::Url::Encode(options.ResourceGroupName) : "null");
  url.AppendPath("providers/Microsoft.Storage/storageAccounts/");
  url.AppendPath(!options.AccountName.empty() ? Core::Url::Encode(options.AccountName) : "null");
  url.AppendPath("tableServices/default/tables");

  url.SetQueryParameters({{"api-version", "2023-01-01"}});

  Core::Http::Request request(Core::Http::HttpMethod::Get, url);

  auto rawResponse = m_pipeline->Send(request, context);
  auto const httpStatusCode = rawResponse->GetStatusCode();

  if (httpStatusCode != Core::Http::HttpStatusCode::Ok)
  {
    throw Core::RequestFailedException(rawResponse);
  }

  ListTableResource response{};
  {
    auto const& responseBody = rawResponse->GetBody();
    std::string responseString = std::string(responseBody.begin(), responseBody.end());
    if (responseBody.size() > 0)
    {
      auto const jsonRoot
          = Core::Json::_internal::json::parse(responseBody.begin(), responseBody.end());

      for (auto const& jsonValue : jsonRoot["value"])
      {
        Table vectorItem{};

        vectorItem.Properties.TableName = jsonValue["properties"]["tableName"].get<std::string>();
        if (jsonValue["properties"].contains("signedIdentifiers"))
        {
          for (auto const& jsonItem : jsonValue["properties"]["signedIdentifiers"])
          {
            TableSignedIdentifier subItem{};

            subItem.Id = jsonItem["id"].get<std::string>();

            if (jsonItem.contains("startTime"))
            {
              subItem.AccessPolicy.StartTime = DateTime::Parse(
                  jsonItem["startTime"].get<std::string>(), DateTime::DateFormat::Rfc3339);
            }

            if (jsonItem.contains("expiryTime"))
            {
              subItem.AccessPolicy.ExpiryTime = DateTime::Parse(
                  jsonItem["expiryTime"].get<std::string>(), DateTime::DateFormat::Rfc3339);
            }

            subItem.AccessPolicy.Permission = jsonItem["permission"].get<std::string>();

            vectorItem.Properties.SignedIdentifiers.emplace_back(std::move(subItem));
          }
        }
        response.Value.emplace_back(std::move(vectorItem));
      }
      if (jsonRoot.contains("nextLink"))
      {
        response.NextLink = jsonRoot["nextLink"].get<std::string>();
      }
    }
  }

  return Response<ListTableResource>(std::move(response), std::move(rawResponse));
}
