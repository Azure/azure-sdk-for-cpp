// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.


// THIS FILE IS AUTOGENERATED!
// DO NOT EDIT!


#ifndef TIMEDISCRETEMICROMOCKCALLMACROS_H
#define TIMEDISCRETEMICROMOCKCALLMACROS_H

#pragma once


#define MOCK_TD_METHOD_0(prefix, resultType, name) \
    MOCK_METHOD_0(prefix, resultType, name)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_STATIC_TD_METHOD_0(prefix, resultType, name) \
    MOCK_STATIC_METHOD_0(prefix, resultType, name)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_TD_METHOD_1(prefix, resultType, name, arg1Type, arg1Value) \
    MOCK_METHOD_1(prefix, resultType, name, arg1Type, arg1Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_STATIC_TD_METHOD_1(prefix, resultType, name, arg1Type, arg1Value) \
    MOCK_STATIC_METHOD_1(prefix, resultType, name, arg1Type, arg1Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_TD_METHOD_2(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value) \
    MOCK_METHOD_2(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_STATIC_TD_METHOD_2(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value) \
    MOCK_STATIC_METHOD_2(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_TD_METHOD_3(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value) \
    MOCK_METHOD_3(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_STATIC_TD_METHOD_3(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value) \
    MOCK_STATIC_METHOD_3(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_TD_METHOD_4(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value) \
    MOCK_METHOD_4(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_STATIC_TD_METHOD_4(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value) \
    MOCK_STATIC_METHOD_4(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_TD_METHOD_5(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value) \
    MOCK_METHOD_5(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_STATIC_TD_METHOD_5(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value) \
    MOCK_STATIC_METHOD_5(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_TD_METHOD_6(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value) \
    MOCK_METHOD_6(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_STATIC_TD_METHOD_6(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value) \
    MOCK_STATIC_METHOD_6(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_TD_METHOD_7(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value) \
    MOCK_METHOD_7(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_STATIC_TD_METHOD_7(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value) \
    MOCK_STATIC_METHOD_7(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_TD_METHOD_8(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value) \
    MOCK_METHOD_8(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_STATIC_TD_METHOD_8(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value) \
    MOCK_STATIC_METHOD_8(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_TD_METHOD_9(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value) \
    MOCK_METHOD_9(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_STATIC_TD_METHOD_9(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value) \
    MOCK_STATIC_METHOD_9(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_TD_METHOD_10(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value) \
    MOCK_METHOD_10(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_STATIC_TD_METHOD_10(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value) \
    MOCK_STATIC_METHOD_10(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_TD_METHOD_11(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value) \
    MOCK_METHOD_11(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_STATIC_TD_METHOD_11(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value) \
    MOCK_STATIC_METHOD_11(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_TD_METHOD_12(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value) \
    MOCK_METHOD_12(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_STATIC_TD_METHOD_12(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value) \
    MOCK_STATIC_METHOD_12(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_TD_METHOD_13(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value) \
    MOCK_METHOD_13(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_STATIC_TD_METHOD_13(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value) \
    MOCK_STATIC_METHOD_13(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_TD_METHOD_14(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value, arg14Type, arg14Value) \
    MOCK_METHOD_14(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value, arg14Type, arg14Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_STATIC_TD_METHOD_14(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value, arg14Type, arg14Value) \
    MOCK_STATIC_METHOD_14(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value, arg14Type, arg14Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_TD_METHOD_15(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value, arg14Type, arg14Value, arg15Type, arg15Value) \
    MOCK_METHOD_15(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value, arg14Type, arg14Value, arg15Type, arg15Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define MOCK_STATIC_TD_METHOD_15(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value, arg14Type, arg14Value, arg15Type, arg15Value) \
    MOCK_STATIC_METHOD_15(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value, arg14Type, arg14Value, arg15Type, arg15Value)\
    mockMethodCall->AddExtraCallArgument(new CMockCallArgument<UINT32>(MOCK_TIMEPROVIDER(__FUNCTION__)));\
    result = REMATCH_ACTUAL_STATIC_MOCK_CALL(mockMethodCall);\

#define STIM_CALL_AT(var, time, ...)    var.__VA_ARGS__.SetTime(time, var.getAndIncOrder(time))

#define DECLARE_STIM_STATIC_TD_METHOD_0(prefix, resultType, name)\
class pFunctionCall_Wrapper_##name \
{\
    public:\
    typedef resultType (*pRealFunctionType)();\
    static pRealFunctionType realFunction;\
};\
pFunctionCall_Wrapper_##name::pRealFunctionType pFunctionCall_Wrapper_##name::realFunction = ::name; /*so this never can go to a header*/

#define STIM_STATIC_TD_METHOD_0(prefix, resultType, name ) call0Arg<resultType, pFunctionCall_Wrapper_##name > name;

#define DECLARE_STIM_STATIC_TD_METHOD_1(prefix, resultType, name, arg1Type, arg1Value)\
class pFunctionCall_Wrapper_##name \
{\
    public:\
    typedef resultType (*pRealFunctionType)(arg1Type arg1Value);\
    static pRealFunctionType realFunction;\
};\
pFunctionCall_Wrapper_##name::pRealFunctionType pFunctionCall_Wrapper_##name::realFunction = ::name; /*so this never can go to a header*/

#define STIM_STATIC_TD_METHOD_1(prefix, resultType, name , arg1Type, arg1Value) call1Arg<resultType, arg1Type, pFunctionCall_Wrapper_##name > name;

#define DECLARE_STIM_STATIC_TD_METHOD_2(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value)\
class pFunctionCall_Wrapper_##name \
{\
    public:\
    typedef resultType (*pRealFunctionType)(arg1Type arg1Value, arg2Type arg2Value);\
    static pRealFunctionType realFunction;\
};\
pFunctionCall_Wrapper_##name::pRealFunctionType pFunctionCall_Wrapper_##name::realFunction = ::name; /*so this never can go to a header*/

#define STIM_STATIC_TD_METHOD_2(prefix, resultType, name , arg1Type, arg1Value, arg2Type, arg2Value) call2Arg<resultType, arg1Type, arg2Type, pFunctionCall_Wrapper_##name > name;

#define DECLARE_STIM_STATIC_TD_METHOD_3(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value)\
class pFunctionCall_Wrapper_##name \
{\
    public:\
    typedef resultType (*pRealFunctionType)(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value);\
    static pRealFunctionType realFunction;\
};\
pFunctionCall_Wrapper_##name::pRealFunctionType pFunctionCall_Wrapper_##name::realFunction = ::name; /*so this never can go to a header*/

#define STIM_STATIC_TD_METHOD_3(prefix, resultType, name , arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value) call3Arg<resultType, arg1Type, arg2Type, arg3Type, pFunctionCall_Wrapper_##name > name;

#define DECLARE_STIM_STATIC_TD_METHOD_4(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value)\
class pFunctionCall_Wrapper_##name \
{\
    public:\
    typedef resultType (*pRealFunctionType)(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value);\
    static pRealFunctionType realFunction;\
};\
pFunctionCall_Wrapper_##name::pRealFunctionType pFunctionCall_Wrapper_##name::realFunction = ::name; /*so this never can go to a header*/

#define STIM_STATIC_TD_METHOD_4(prefix, resultType, name , arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value) call4Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, pFunctionCall_Wrapper_##name > name;

#define DECLARE_STIM_STATIC_TD_METHOD_5(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value)\
class pFunctionCall_Wrapper_##name \
{\
    public:\
    typedef resultType (*pRealFunctionType)(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value);\
    static pRealFunctionType realFunction;\
};\
pFunctionCall_Wrapper_##name::pRealFunctionType pFunctionCall_Wrapper_##name::realFunction = ::name; /*so this never can go to a header*/

#define STIM_STATIC_TD_METHOD_5(prefix, resultType, name , arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value) call5Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, pFunctionCall_Wrapper_##name > name;

#define DECLARE_STIM_STATIC_TD_METHOD_6(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value)\
class pFunctionCall_Wrapper_##name \
{\
    public:\
    typedef resultType (*pRealFunctionType)(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value);\
    static pRealFunctionType realFunction;\
};\
pFunctionCall_Wrapper_##name::pRealFunctionType pFunctionCall_Wrapper_##name::realFunction = ::name; /*so this never can go to a header*/

#define STIM_STATIC_TD_METHOD_6(prefix, resultType, name , arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value) call6Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, pFunctionCall_Wrapper_##name > name;

#define DECLARE_STIM_STATIC_TD_METHOD_7(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value)\
class pFunctionCall_Wrapper_##name \
{\
    public:\
    typedef resultType (*pRealFunctionType)(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value);\
    static pRealFunctionType realFunction;\
};\
pFunctionCall_Wrapper_##name::pRealFunctionType pFunctionCall_Wrapper_##name::realFunction = ::name; /*so this never can go to a header*/

#define STIM_STATIC_TD_METHOD_7(prefix, resultType, name , arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value) call7Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, pFunctionCall_Wrapper_##name > name;

#define DECLARE_STIM_STATIC_TD_METHOD_8(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value)\
class pFunctionCall_Wrapper_##name \
{\
    public:\
    typedef resultType (*pRealFunctionType)(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value, arg8Type arg8Value);\
    static pRealFunctionType realFunction;\
};\
pFunctionCall_Wrapper_##name::pRealFunctionType pFunctionCall_Wrapper_##name::realFunction = ::name; /*so this never can go to a header*/

#define STIM_STATIC_TD_METHOD_8(prefix, resultType, name , arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value) call8Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, pFunctionCall_Wrapper_##name > name;

#define DECLARE_STIM_STATIC_TD_METHOD_9(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value)\
class pFunctionCall_Wrapper_##name \
{\
    public:\
    typedef resultType (*pRealFunctionType)(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value, arg8Type arg8Value, arg9Type arg9Value);\
    static pRealFunctionType realFunction;\
};\
pFunctionCall_Wrapper_##name::pRealFunctionType pFunctionCall_Wrapper_##name::realFunction = ::name; /*so this never can go to a header*/

#define STIM_STATIC_TD_METHOD_9(prefix, resultType, name , arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value) call9Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, pFunctionCall_Wrapper_##name > name;

#define DECLARE_STIM_STATIC_TD_METHOD_10(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value)\
class pFunctionCall_Wrapper_##name \
{\
    public:\
    typedef resultType (*pRealFunctionType)(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value, arg8Type arg8Value, arg9Type arg9Value, arg10Type arg10Value);\
    static pRealFunctionType realFunction;\
};\
pFunctionCall_Wrapper_##name::pRealFunctionType pFunctionCall_Wrapper_##name::realFunction = ::name; /*so this never can go to a header*/

#define STIM_STATIC_TD_METHOD_10(prefix, resultType, name , arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value) call10Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, pFunctionCall_Wrapper_##name > name;

#define DECLARE_STIM_STATIC_TD_METHOD_11(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value)\
class pFunctionCall_Wrapper_##name \
{\
    public:\
    typedef resultType (*pRealFunctionType)(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value, arg8Type arg8Value, arg9Type arg9Value, arg10Type arg10Value, arg11Type arg11Value);\
    static pRealFunctionType realFunction;\
};\
pFunctionCall_Wrapper_##name::pRealFunctionType pFunctionCall_Wrapper_##name::realFunction = ::name; /*so this never can go to a header*/

#define STIM_STATIC_TD_METHOD_11(prefix, resultType, name , arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value) call11Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, pFunctionCall_Wrapper_##name > name;

#define DECLARE_STIM_STATIC_TD_METHOD_12(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value)\
class pFunctionCall_Wrapper_##name \
{\
    public:\
    typedef resultType (*pRealFunctionType)(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value, arg8Type arg8Value, arg9Type arg9Value, arg10Type arg10Value, arg11Type arg11Value, arg12Type arg12Value);\
    static pRealFunctionType realFunction;\
};\
pFunctionCall_Wrapper_##name::pRealFunctionType pFunctionCall_Wrapper_##name::realFunction = ::name; /*so this never can go to a header*/

#define STIM_STATIC_TD_METHOD_12(prefix, resultType, name , arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value) call12Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type, pFunctionCall_Wrapper_##name > name;

#define DECLARE_STIM_STATIC_TD_METHOD_13(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value)\
class pFunctionCall_Wrapper_##name \
{\
    public:\
    typedef resultType (*pRealFunctionType)(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value, arg8Type arg8Value, arg9Type arg9Value, arg10Type arg10Value, arg11Type arg11Value, arg12Type arg12Value, arg13Type arg13Value);\
    static pRealFunctionType realFunction;\
};\
pFunctionCall_Wrapper_##name::pRealFunctionType pFunctionCall_Wrapper_##name::realFunction = ::name; /*so this never can go to a header*/

#define STIM_STATIC_TD_METHOD_13(prefix, resultType, name , arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value) call13Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type, arg13Type, pFunctionCall_Wrapper_##name > name;

#define DECLARE_STIM_STATIC_TD_METHOD_14(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value, arg14Type, arg14Value)\
class pFunctionCall_Wrapper_##name \
{\
    public:\
    typedef resultType (*pRealFunctionType)(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value, arg8Type arg8Value, arg9Type arg9Value, arg10Type arg10Value, arg11Type arg11Value, arg12Type arg12Value, arg13Type arg13Value, arg14Type arg14Value);\
    static pRealFunctionType realFunction;\
};\
pFunctionCall_Wrapper_##name::pRealFunctionType pFunctionCall_Wrapper_##name::realFunction = ::name; /*so this never can go to a header*/

#define STIM_STATIC_TD_METHOD_14(prefix, resultType, name , arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value, arg14Type, arg14Value) call14Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type, arg13Type, arg14Type, pFunctionCall_Wrapper_##name > name;

#define DECLARE_STIM_STATIC_TD_METHOD_15(prefix, resultType, name, arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value, arg14Type, arg14Value, arg15Type, arg15Value)\
class pFunctionCall_Wrapper_##name \
{\
    public:\
    typedef resultType (*pRealFunctionType)(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value, arg8Type arg8Value, arg9Type arg9Value, arg10Type arg10Value, arg11Type arg11Value, arg12Type arg12Value, arg13Type arg13Value, arg14Type arg14Value, arg15Type arg15Value);\
    static pRealFunctionType realFunction;\
};\
pFunctionCall_Wrapper_##name::pRealFunctionType pFunctionCall_Wrapper_##name::realFunction = ::name; /*so this never can go to a header*/

#define STIM_STATIC_TD_METHOD_15(prefix, resultType, name , arg1Type, arg1Value, arg2Type, arg2Value, arg3Type, arg3Value, arg4Type, arg4Value, arg5Type, arg5Value, arg6Type, arg6Value, arg7Type, arg7Value, arg8Type, arg8Value, arg9Type, arg9Value, arg10Type, arg10Value, arg11Type, arg11Value, arg12Type, arg12Value, arg13Type, arg13Value, arg14Type, arg14Value, arg15Type, arg15Value) call15Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type, arg13Type, arg14Type, arg15Type, pFunctionCall_Wrapper_##name > name;

template<typename resultType,class C>class call0Arg : public canPlay
{
private:
    class timeS
    {
    public:
        timeS():
        time(0), order(0)
        {
        }
        UINT32 time;
        UINT32 order;
    };
    std::vector<timeS> allCalls;
public:
    call0Arg()
    {
        stims_base::registerCallXArg(this);
    }

    virtual ~call0Arg<resultType,  C>()
    {
    }
    virtual void PlayTick(_In_ UINT32 tick, _In_ UINT32 order)
    {
        for(UINT32 i=0; i<allCalls.size();i++)
        {
            if((allCalls[i].time==tick)&&(allCalls[i].order==order))
            {
                C::realFunction();
            }
        }
    }

    call0Arg<resultType, C>& SetTime(_In_ UINT32 time, _In_ UINT32 order)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_TIME_BEFORE_CALL, _T("using SetTime before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            allCalls[allCalls.size()-1].time=time;
            allCalls[allCalls.size()-1].order=order;
        }
        return *this;
    }

    call0Arg<resultType,  C>& operator()()
    {
        timeS s;
        allCalls.push_back(s); /*time is updated "later" by chaining*/
        return *this;
    }

};

template<typename resultType,typename arg1Type, class C>class call1Arg : public canPlay
{
private:
    class timeS
    {
    public:
        timeS(arg1Type arg1Value):
        time(0), order(0), arg1(arg1Value)
        {
        }
        UINT32 time;
        UINT32 order;
        valueHolder<arg1Type> arg1;
    };
    std::vector<timeS> allCalls;
public:
    call1Arg()
    {
        stims_base::registerCallXArg(this);
    }

    virtual ~call1Arg<resultType, arg1Type,  C>()
    {
    }
    virtual void PlayTick(_In_ UINT32 tick, _In_ UINT32 order)
    {
        for(UINT32 i=0; i<allCalls.size();i++)
        {
            if((allCalls[i].time==tick)&&(allCalls[i].order==order))
            {
                C::realFunction(allCalls[i].arg1);
            }
        }
    }

    call1Arg<resultType, arg1Type, C>& SetTime(_In_ UINT32 time, _In_ UINT32 order)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_TIME_BEFORE_CALL, _T("using SetTime before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            allCalls[allCalls.size()-1].time=time;
            allCalls[allCalls.size()-1].order=order;
        }
        return *this;
    }

    call1Arg<resultType, arg1Type,  C>& operator()(arg1Type arg1)
    {
        timeS s(arg1);
        allCalls.push_back(s); /*time is updated "later" by chaining*/
        return *this;
    }

    call1Arg<resultType, arg1Type,  C>& setArraySize(_In_ UINT32 parameter, _In_ size_t nElements)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_ARRAY_SIZE_BEFORE_CALL, _T("using setArraySize before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            timeS& s = allCalls[allCalls.size()-1]; /*get the last element*/
            switch(parameter)
            {
                case 1:
                {
                    s.arg1.setArraySize(nElements);
                    break;
                }
                default:
                {
                    ASSERT_FAIL(_T("there are no parameters so big"));
                }
            }
            return *this;
        }
    }
};

template<typename resultType,typename arg1Type, typename arg2Type, class C>class call2Arg : public canPlay
{
private:
    class timeS
    {
    public:
        timeS(arg1Type arg1Value, arg2Type arg2Value):
        time(0), order(0), arg1(arg1Value), arg2(arg2Value)
        {
        }
        UINT32 time;
        UINT32 order;
        valueHolder<arg1Type> arg1;
        valueHolder<arg2Type> arg2;
    };
    std::vector<timeS> allCalls;
public:
    call2Arg()
    {
        stims_base::registerCallXArg(this);
    }

    virtual ~call2Arg<resultType, arg1Type, arg2Type,  C>()
    {
    }
    virtual void PlayTick(_In_ UINT32 tick, _In_ UINT32 order)
    {
        for(UINT32 i=0; i<allCalls.size();i++)
        {
            if((allCalls[i].time==tick)&&(allCalls[i].order==order))
            {
                C::realFunction(allCalls[i].arg1, allCalls[i].arg2);
            }
        }
    }

    call2Arg<resultType, arg1Type, arg2Type, C>& SetTime(_In_ UINT32 time, _In_ UINT32 order)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_TIME_BEFORE_CALL, _T("using SetTime before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            allCalls[allCalls.size()-1].time=time;
            allCalls[allCalls.size()-1].order=order;
        }
        return *this;
    }

    call2Arg<resultType, arg1Type, arg2Type,  C>& operator()(arg1Type arg1,arg2Type arg2)
    {
        timeS s(arg1, arg2);
        allCalls.push_back(s); /*time is updated "later" by chaining*/
        return *this;
    }

    call2Arg<resultType, arg1Type, arg2Type,  C>& setArraySize(_In_ UINT32 parameter, _In_ size_t nElements)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_ARRAY_SIZE_BEFORE_CALL, _T("using setArraySize before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            timeS& s = allCalls[allCalls.size()-1]; /*get the last element*/
            switch(parameter)
            {
                case 1:
                {
                    s.arg1.setArraySize(nElements);
                    break;
                }
                case 2:
                {
                    s.arg2.setArraySize(nElements);
                    break;
                }
                default:
                {
                    ASSERT_FAIL(_T("there are no parameters so big"));
                }
            }
            return *this;
        }
    }
};

template<typename resultType,typename arg1Type, typename arg2Type, typename arg3Type, class C>class call3Arg : public canPlay
{
private:
    class timeS
    {
    public:
        timeS(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value):
        time(0), order(0), arg1(arg1Value), arg2(arg2Value), arg3(arg3Value)
        {
        }
        UINT32 time;
        UINT32 order;
        valueHolder<arg1Type> arg1;
        valueHolder<arg2Type> arg2;
        valueHolder<arg3Type> arg3;
    };
    std::vector<timeS> allCalls;
public:
    call3Arg()
    {
        stims_base::registerCallXArg(this);
    }

    virtual ~call3Arg<resultType, arg1Type, arg2Type, arg3Type,  C>()
    {
    }
    virtual void PlayTick(_In_ UINT32 tick, _In_ UINT32 order)
    {
        for(UINT32 i=0; i<allCalls.size();i++)
        {
            if((allCalls[i].time==tick)&&(allCalls[i].order==order))
            {
                C::realFunction(allCalls[i].arg1, allCalls[i].arg2, allCalls[i].arg3);
            }
        }
    }

    call3Arg<resultType, arg1Type, arg2Type, arg3Type, C>& SetTime(_In_ UINT32 time, _In_ UINT32 order)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_TIME_BEFORE_CALL, _T("using SetTime before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            allCalls[allCalls.size()-1].time=time;
            allCalls[allCalls.size()-1].order=order;
        }
        return *this;
    }

    call3Arg<resultType, arg1Type, arg2Type, arg3Type,  C>& operator()(arg1Type arg1,arg2Type arg2,arg3Type arg3)
    {
        timeS s(arg1, arg2, arg3);
        allCalls.push_back(s); /*time is updated "later" by chaining*/
        return *this;
    }

    call3Arg<resultType, arg1Type, arg2Type, arg3Type,  C>& setArraySize(_In_ UINT32 parameter, _In_ size_t nElements)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_ARRAY_SIZE_BEFORE_CALL, _T("using setArraySize before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            timeS& s = allCalls[allCalls.size()-1]; /*get the last element*/
            switch(parameter)
            {
                case 1:
                {
                    s.arg1.setArraySize(nElements);
                    break;
                }
                case 2:
                {
                    s.arg2.setArraySize(nElements);
                    break;
                }
                case 3:
                {
                    s.arg3.setArraySize(nElements);
                    break;
                }
                default:
                {
                    ASSERT_FAIL(_T("there are no parameters so big"));
                }
            }
            return *this;
        }
    }
};

template<typename resultType,typename arg1Type, typename arg2Type, typename arg3Type, typename arg4Type, class C>class call4Arg : public canPlay
{
private:
    class timeS
    {
    public:
        timeS(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value):
        time(0), order(0), arg1(arg1Value), arg2(arg2Value), arg3(arg3Value), arg4(arg4Value)
        {
        }
        UINT32 time;
        UINT32 order;
        valueHolder<arg1Type> arg1;
        valueHolder<arg2Type> arg2;
        valueHolder<arg3Type> arg3;
        valueHolder<arg4Type> arg4;
    };
    std::vector<timeS> allCalls;
public:
    call4Arg()
    {
        stims_base::registerCallXArg(this);
    }

    virtual ~call4Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type,  C>()
    {
    }
    virtual void PlayTick(_In_ UINT32 tick, _In_ UINT32 order)
    {
        for(UINT32 i=0; i<allCalls.size();i++)
        {
            if((allCalls[i].time==tick)&&(allCalls[i].order==order))
            {
                C::realFunction(allCalls[i].arg1, allCalls[i].arg2, allCalls[i].arg3, allCalls[i].arg4);
            }
        }
    }

    call4Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, C>& SetTime(_In_ UINT32 time, _In_ UINT32 order)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_TIME_BEFORE_CALL, _T("using SetTime before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            allCalls[allCalls.size()-1].time=time;
            allCalls[allCalls.size()-1].order=order;
        }
        return *this;
    }

    call4Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type,  C>& operator()(arg1Type arg1,arg2Type arg2,arg3Type arg3,arg4Type arg4)
    {
        timeS s(arg1, arg2, arg3, arg4);
        allCalls.push_back(s); /*time is updated "later" by chaining*/
        return *this;
    }

    call4Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type,  C>& setArraySize(_In_ UINT32 parameter, _In_ size_t nElements)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_ARRAY_SIZE_BEFORE_CALL, _T("using setArraySize before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            timeS& s = allCalls[allCalls.size()-1]; /*get the last element*/
            switch(parameter)
            {
                case 1:
                {
                    s.arg1.setArraySize(nElements);
                    break;
                }
                case 2:
                {
                    s.arg2.setArraySize(nElements);
                    break;
                }
                case 3:
                {
                    s.arg3.setArraySize(nElements);
                    break;
                }
                case 4:
                {
                    s.arg4.setArraySize(nElements);
                    break;
                }
                default:
                {
                    ASSERT_FAIL(_T("there are no parameters so big"));
                }
            }
            return *this;
        }
    }
};

template<typename resultType,typename arg1Type, typename arg2Type, typename arg3Type, typename arg4Type, typename arg5Type, class C>class call5Arg : public canPlay
{
private:
    class timeS
    {
    public:
        timeS(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value):
        time(0), order(0), arg1(arg1Value), arg2(arg2Value), arg3(arg3Value), arg4(arg4Value), arg5(arg5Value)
        {
        }
        UINT32 time;
        UINT32 order;
        valueHolder<arg1Type> arg1;
        valueHolder<arg2Type> arg2;
        valueHolder<arg3Type> arg3;
        valueHolder<arg4Type> arg4;
        valueHolder<arg5Type> arg5;
    };
    std::vector<timeS> allCalls;
public:
    call5Arg()
    {
        stims_base::registerCallXArg(this);
    }

    virtual ~call5Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type,  C>()
    {
    }
    virtual void PlayTick(_In_ UINT32 tick, _In_ UINT32 order)
    {
        for(UINT32 i=0; i<allCalls.size();i++)
        {
            if((allCalls[i].time==tick)&&(allCalls[i].order==order))
            {
                C::realFunction(allCalls[i].arg1, allCalls[i].arg2, allCalls[i].arg3, allCalls[i].arg4, allCalls[i].arg5);
            }
        }
    }

    call5Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, C>& SetTime(_In_ UINT32 time, _In_ UINT32 order)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_TIME_BEFORE_CALL, _T("using SetTime before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            allCalls[allCalls.size()-1].time=time;
            allCalls[allCalls.size()-1].order=order;
        }
        return *this;
    }

    call5Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type,  C>& operator()(arg1Type arg1,arg2Type arg2,arg3Type arg3,arg4Type arg4,arg5Type arg5)
    {
        timeS s(arg1, arg2, arg3, arg4, arg5);
        allCalls.push_back(s); /*time is updated "later" by chaining*/
        return *this;
    }

    call5Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type,  C>& setArraySize(_In_ UINT32 parameter, _In_ size_t nElements)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_ARRAY_SIZE_BEFORE_CALL, _T("using setArraySize before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            timeS& s = allCalls[allCalls.size()-1]; /*get the last element*/
            switch(parameter)
            {
                case 1:
                {
                    s.arg1.setArraySize(nElements);
                    break;
                }
                case 2:
                {
                    s.arg2.setArraySize(nElements);
                    break;
                }
                case 3:
                {
                    s.arg3.setArraySize(nElements);
                    break;
                }
                case 4:
                {
                    s.arg4.setArraySize(nElements);
                    break;
                }
                case 5:
                {
                    s.arg5.setArraySize(nElements);
                    break;
                }
                default:
                {
                    ASSERT_FAIL(_T("there are no parameters so big"));
                }
            }
            return *this;
        }
    }
};

template<typename resultType,typename arg1Type, typename arg2Type, typename arg3Type, typename arg4Type, typename arg5Type, typename arg6Type, class C>class call6Arg : public canPlay
{
private:
    class timeS
    {
    public:
        timeS(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value):
        time(0), order(0), arg1(arg1Value), arg2(arg2Value), arg3(arg3Value), arg4(arg4Value), arg5(arg5Value), arg6(arg6Value)
        {
        }
        UINT32 time;
        UINT32 order;
        valueHolder<arg1Type> arg1;
        valueHolder<arg2Type> arg2;
        valueHolder<arg3Type> arg3;
        valueHolder<arg4Type> arg4;
        valueHolder<arg5Type> arg5;
        valueHolder<arg6Type> arg6;
    };
    std::vector<timeS> allCalls;
public:
    call6Arg()
    {
        stims_base::registerCallXArg(this);
    }

    virtual ~call6Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type,  C>()
    {
    }
    virtual void PlayTick(_In_ UINT32 tick, _In_ UINT32 order)
    {
        for(UINT32 i=0; i<allCalls.size();i++)
        {
            if((allCalls[i].time==tick)&&(allCalls[i].order==order))
            {
                C::realFunction(allCalls[i].arg1, allCalls[i].arg2, allCalls[i].arg3, allCalls[i].arg4, allCalls[i].arg5, allCalls[i].arg6);
            }
        }
    }

    call6Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, C>& SetTime(_In_ UINT32 time, _In_ UINT32 order)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_TIME_BEFORE_CALL, _T("using SetTime before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            allCalls[allCalls.size()-1].time=time;
            allCalls[allCalls.size()-1].order=order;
        }
        return *this;
    }

    call6Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type,  C>& operator()(arg1Type arg1,arg2Type arg2,arg3Type arg3,arg4Type arg4,arg5Type arg5,arg6Type arg6)
    {
        timeS s(arg1, arg2, arg3, arg4, arg5, arg6);
        allCalls.push_back(s); /*time is updated "later" by chaining*/
        return *this;
    }

    call6Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type,  C>& setArraySize(_In_ UINT32 parameter, _In_ size_t nElements)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_ARRAY_SIZE_BEFORE_CALL, _T("using setArraySize before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            timeS& s = allCalls[allCalls.size()-1]; /*get the last element*/
            switch(parameter)
            {
                case 1:
                {
                    s.arg1.setArraySize(nElements);
                    break;
                }
                case 2:
                {
                    s.arg2.setArraySize(nElements);
                    break;
                }
                case 3:
                {
                    s.arg3.setArraySize(nElements);
                    break;
                }
                case 4:
                {
                    s.arg4.setArraySize(nElements);
                    break;
                }
                case 5:
                {
                    s.arg5.setArraySize(nElements);
                    break;
                }
                case 6:
                {
                    s.arg6.setArraySize(nElements);
                    break;
                }
                default:
                {
                    ASSERT_FAIL(_T("there are no parameters so big"));
                }
            }
            return *this;
        }
    }
};

template<typename resultType,typename arg1Type, typename arg2Type, typename arg3Type, typename arg4Type, typename arg5Type, typename arg6Type, typename arg7Type, class C>class call7Arg : public canPlay
{
private:
    class timeS
    {
    public:
        timeS(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value):
        time(0), order(0), arg1(arg1Value), arg2(arg2Value), arg3(arg3Value), arg4(arg4Value), arg5(arg5Value), arg6(arg6Value), arg7(arg7Value)
        {
        }
        UINT32 time;
        UINT32 order;
        valueHolder<arg1Type> arg1;
        valueHolder<arg2Type> arg2;
        valueHolder<arg3Type> arg3;
        valueHolder<arg4Type> arg4;
        valueHolder<arg5Type> arg5;
        valueHolder<arg6Type> arg6;
        valueHolder<arg7Type> arg7;
    };
    std::vector<timeS> allCalls;
public:
    call7Arg()
    {
        stims_base::registerCallXArg(this);
    }

    virtual ~call7Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type,  C>()
    {
    }
    virtual void PlayTick(_In_ UINT32 tick, _In_ UINT32 order)
    {
        for(UINT32 i=0; i<allCalls.size();i++)
        {
            if((allCalls[i].time==tick)&&(allCalls[i].order==order))
            {
                C::realFunction(allCalls[i].arg1, allCalls[i].arg2, allCalls[i].arg3, allCalls[i].arg4, allCalls[i].arg5, allCalls[i].arg6, allCalls[i].arg7);
            }
        }
    }

    call7Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, C>& SetTime(_In_ UINT32 time, _In_ UINT32 order)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_TIME_BEFORE_CALL, _T("using SetTime before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            allCalls[allCalls.size()-1].time=time;
            allCalls[allCalls.size()-1].order=order;
        }
        return *this;
    }

    call7Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type,  C>& operator()(arg1Type arg1,arg2Type arg2,arg3Type arg3,arg4Type arg4,arg5Type arg5,arg6Type arg6,arg7Type arg7)
    {
        timeS s(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        allCalls.push_back(s); /*time is updated "later" by chaining*/
        return *this;
    }

    call7Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type,  C>& setArraySize(_In_ UINT32 parameter, _In_ size_t nElements)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_ARRAY_SIZE_BEFORE_CALL, _T("using setArraySize before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            timeS& s = allCalls[allCalls.size()-1]; /*get the last element*/
            switch(parameter)
            {
                case 1:
                {
                    s.arg1.setArraySize(nElements);
                    break;
                }
                case 2:
                {
                    s.arg2.setArraySize(nElements);
                    break;
                }
                case 3:
                {
                    s.arg3.setArraySize(nElements);
                    break;
                }
                case 4:
                {
                    s.arg4.setArraySize(nElements);
                    break;
                }
                case 5:
                {
                    s.arg5.setArraySize(nElements);
                    break;
                }
                case 6:
                {
                    s.arg6.setArraySize(nElements);
                    break;
                }
                case 7:
                {
                    s.arg7.setArraySize(nElements);
                    break;
                }
                default:
                {
                    ASSERT_FAIL(_T("there are no parameters so big"));
                }
            }
            return *this;
        }
    }
};

template<typename resultType,typename arg1Type, typename arg2Type, typename arg3Type, typename arg4Type, typename arg5Type, typename arg6Type, typename arg7Type, typename arg8Type, class C>class call8Arg : public canPlay
{
private:
    class timeS
    {
    public:
        timeS(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value, arg8Type arg8Value):
        time(0), order(0), arg1(arg1Value), arg2(arg2Value), arg3(arg3Value), arg4(arg4Value), arg5(arg5Value), arg6(arg6Value), arg7(arg7Value), arg8(arg8Value)
        {
        }
        UINT32 time;
        UINT32 order;
        valueHolder<arg1Type> arg1;
        valueHolder<arg2Type> arg2;
        valueHolder<arg3Type> arg3;
        valueHolder<arg4Type> arg4;
        valueHolder<arg5Type> arg5;
        valueHolder<arg6Type> arg6;
        valueHolder<arg7Type> arg7;
        valueHolder<arg8Type> arg8;
    };
    std::vector<timeS> allCalls;
public:
    call8Arg()
    {
        stims_base::registerCallXArg(this);
    }

    virtual ~call8Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type,  C>()
    {
    }
    virtual void PlayTick(_In_ UINT32 tick, _In_ UINT32 order)
    {
        for(UINT32 i=0; i<allCalls.size();i++)
        {
            if((allCalls[i].time==tick)&&(allCalls[i].order==order))
            {
                C::realFunction(allCalls[i].arg1, allCalls[i].arg2, allCalls[i].arg3, allCalls[i].arg4, allCalls[i].arg5, allCalls[i].arg6, allCalls[i].arg7, allCalls[i].arg8);
            }
        }
    }

    call8Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, C>& SetTime(_In_ UINT32 time, _In_ UINT32 order)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_TIME_BEFORE_CALL, _T("using SetTime before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            allCalls[allCalls.size()-1].time=time;
            allCalls[allCalls.size()-1].order=order;
        }
        return *this;
    }

    call8Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type,  C>& operator()(arg1Type arg1,arg2Type arg2,arg3Type arg3,arg4Type arg4,arg5Type arg5,arg6Type arg6,arg7Type arg7,arg8Type arg8)
    {
        timeS s(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        allCalls.push_back(s); /*time is updated "later" by chaining*/
        return *this;
    }

    call8Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type,  C>& setArraySize(_In_ UINT32 parameter, _In_ size_t nElements)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_ARRAY_SIZE_BEFORE_CALL, _T("using setArraySize before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            timeS& s = allCalls[allCalls.size()-1]; /*get the last element*/
            switch(parameter)
            {
                case 1:
                {
                    s.arg1.setArraySize(nElements);
                    break;
                }
                case 2:
                {
                    s.arg2.setArraySize(nElements);
                    break;
                }
                case 3:
                {
                    s.arg3.setArraySize(nElements);
                    break;
                }
                case 4:
                {
                    s.arg4.setArraySize(nElements);
                    break;
                }
                case 5:
                {
                    s.arg5.setArraySize(nElements);
                    break;
                }
                case 6:
                {
                    s.arg6.setArraySize(nElements);
                    break;
                }
                case 7:
                {
                    s.arg7.setArraySize(nElements);
                    break;
                }
                case 8:
                {
                    s.arg8.setArraySize(nElements);
                    break;
                }
                default:
                {
                    ASSERT_FAIL(_T("there are no parameters so big"));
                }
            }
            return *this;
        }
    }
};

template<typename resultType,typename arg1Type, typename arg2Type, typename arg3Type, typename arg4Type, typename arg5Type, typename arg6Type, typename arg7Type, typename arg8Type, typename arg9Type, class C>class call9Arg : public canPlay
{
private:
    class timeS
    {
    public:
        timeS(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value, arg8Type arg8Value, arg9Type arg9Value):
        time(0), order(0), arg1(arg1Value), arg2(arg2Value), arg3(arg3Value), arg4(arg4Value), arg5(arg5Value), arg6(arg6Value), arg7(arg7Value), arg8(arg8Value), arg9(arg9Value)
        {
        }
        UINT32 time;
        UINT32 order;
        valueHolder<arg1Type> arg1;
        valueHolder<arg2Type> arg2;
        valueHolder<arg3Type> arg3;
        valueHolder<arg4Type> arg4;
        valueHolder<arg5Type> arg5;
        valueHolder<arg6Type> arg6;
        valueHolder<arg7Type> arg7;
        valueHolder<arg8Type> arg8;
        valueHolder<arg9Type> arg9;
    };
    std::vector<timeS> allCalls;
public:
    call9Arg()
    {
        stims_base::registerCallXArg(this);
    }

    virtual ~call9Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type,  C>()
    {
    }
    virtual void PlayTick(_In_ UINT32 tick, _In_ UINT32 order)
    {
        for(UINT32 i=0; i<allCalls.size();i++)
        {
            if((allCalls[i].time==tick)&&(allCalls[i].order==order))
            {
                C::realFunction(allCalls[i].arg1, allCalls[i].arg2, allCalls[i].arg3, allCalls[i].arg4, allCalls[i].arg5, allCalls[i].arg6, allCalls[i].arg7, allCalls[i].arg8, allCalls[i].arg9);
            }
        }
    }

    call9Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, C>& SetTime(_In_ UINT32 time, _In_ UINT32 order)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_TIME_BEFORE_CALL, _T("using SetTime before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            allCalls[allCalls.size()-1].time=time;
            allCalls[allCalls.size()-1].order=order;
        }
        return *this;
    }

    call9Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type,  C>& operator()(arg1Type arg1,arg2Type arg2,arg3Type arg3,arg4Type arg4,arg5Type arg5,arg6Type arg6,arg7Type arg7,arg8Type arg8,arg9Type arg9)
    {
        timeS s(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
        allCalls.push_back(s); /*time is updated "later" by chaining*/
        return *this;
    }

    call9Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type,  C>& setArraySize(_In_ UINT32 parameter, _In_ size_t nElements)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_ARRAY_SIZE_BEFORE_CALL, _T("using setArraySize before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            timeS& s = allCalls[allCalls.size()-1]; /*get the last element*/
            switch(parameter)
            {
                case 1:
                {
                    s.arg1.setArraySize(nElements);
                    break;
                }
                case 2:
                {
                    s.arg2.setArraySize(nElements);
                    break;
                }
                case 3:
                {
                    s.arg3.setArraySize(nElements);
                    break;
                }
                case 4:
                {
                    s.arg4.setArraySize(nElements);
                    break;
                }
                case 5:
                {
                    s.arg5.setArraySize(nElements);
                    break;
                }
                case 6:
                {
                    s.arg6.setArraySize(nElements);
                    break;
                }
                case 7:
                {
                    s.arg7.setArraySize(nElements);
                    break;
                }
                case 8:
                {
                    s.arg8.setArraySize(nElements);
                    break;
                }
                case 9:
                {
                    s.arg9.setArraySize(nElements);
                    break;
                }
                default:
                {
                    ASSERT_FAIL(_T("there are no parameters so big"));
                }
            }
            return *this;
        }
    }
};

template<typename resultType,typename arg1Type, typename arg2Type, typename arg3Type, typename arg4Type, typename arg5Type, typename arg6Type, typename arg7Type, typename arg8Type, typename arg9Type, typename arg10Type, class C>class call10Arg : public canPlay
{
private:
    class timeS
    {
    public:
        timeS(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value, arg8Type arg8Value, arg9Type arg9Value, arg10Type arg10Value):
        time(0), order(0), arg1(arg1Value), arg2(arg2Value), arg3(arg3Value), arg4(arg4Value), arg5(arg5Value), arg6(arg6Value), arg7(arg7Value), arg8(arg8Value), arg9(arg9Value), arg10(arg10Value)
        {
        }
        UINT32 time;
        UINT32 order;
        valueHolder<arg1Type> arg1;
        valueHolder<arg2Type> arg2;
        valueHolder<arg3Type> arg3;
        valueHolder<arg4Type> arg4;
        valueHolder<arg5Type> arg5;
        valueHolder<arg6Type> arg6;
        valueHolder<arg7Type> arg7;
        valueHolder<arg8Type> arg8;
        valueHolder<arg9Type> arg9;
        valueHolder<arg10Type> arg10;
    };
    std::vector<timeS> allCalls;
public:
    call10Arg()
    {
        stims_base::registerCallXArg(this);
    }

    virtual ~call10Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type,  C>()
    {
    }
    virtual void PlayTick(_In_ UINT32 tick, _In_ UINT32 order)
    {
        for(UINT32 i=0; i<allCalls.size();i++)
        {
            if((allCalls[i].time==tick)&&(allCalls[i].order==order))
            {
                C::realFunction(allCalls[i].arg1, allCalls[i].arg2, allCalls[i].arg3, allCalls[i].arg4, allCalls[i].arg5, allCalls[i].arg6, allCalls[i].arg7, allCalls[i].arg8, allCalls[i].arg9, allCalls[i].arg10);
            }
        }
    }

    call10Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, C>& SetTime(_In_ UINT32 time, _In_ UINT32 order)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_TIME_BEFORE_CALL, _T("using SetTime before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            allCalls[allCalls.size()-1].time=time;
            allCalls[allCalls.size()-1].order=order;
        }
        return *this;
    }

    call10Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type,  C>& operator()(arg1Type arg1,arg2Type arg2,arg3Type arg3,arg4Type arg4,arg5Type arg5,arg6Type arg6,arg7Type arg7,arg8Type arg8,arg9Type arg9,arg10Type arg10)
    {
        timeS s(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10);
        allCalls.push_back(s); /*time is updated "later" by chaining*/
        return *this;
    }

    call10Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type,  C>& setArraySize(_In_ UINT32 parameter, _In_ size_t nElements)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_ARRAY_SIZE_BEFORE_CALL, _T("using setArraySize before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            timeS& s = allCalls[allCalls.size()-1]; /*get the last element*/
            switch(parameter)
            {
                case 1:
                {
                    s.arg1.setArraySize(nElements);
                    break;
                }
                case 2:
                {
                    s.arg2.setArraySize(nElements);
                    break;
                }
                case 3:
                {
                    s.arg3.setArraySize(nElements);
                    break;
                }
                case 4:
                {
                    s.arg4.setArraySize(nElements);
                    break;
                }
                case 5:
                {
                    s.arg5.setArraySize(nElements);
                    break;
                }
                case 6:
                {
                    s.arg6.setArraySize(nElements);
                    break;
                }
                case 7:
                {
                    s.arg7.setArraySize(nElements);
                    break;
                }
                case 8:
                {
                    s.arg8.setArraySize(nElements);
                    break;
                }
                case 9:
                {
                    s.arg9.setArraySize(nElements);
                    break;
                }
                case 10:
                {
                    s.arg10.setArraySize(nElements);
                    break;
                }
                default:
                {
                    ASSERT_FAIL(_T("there are no parameters so big"));
                }
            }
            return *this;
        }
    }
};

template<typename resultType,typename arg1Type, typename arg2Type, typename arg3Type, typename arg4Type, typename arg5Type, typename arg6Type, typename arg7Type, typename arg8Type, typename arg9Type, typename arg10Type, typename arg11Type, class C>class call11Arg : public canPlay
{
private:
    class timeS
    {
    public:
        timeS(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value, arg8Type arg8Value, arg9Type arg9Value, arg10Type arg10Value, arg11Type arg11Value):
        time(0), order(0), arg1(arg1Value), arg2(arg2Value), arg3(arg3Value), arg4(arg4Value), arg5(arg5Value), arg6(arg6Value), arg7(arg7Value), arg8(arg8Value), arg9(arg9Value), arg10(arg10Value), arg11(arg11Value)
        {
        }
        UINT32 time;
        UINT32 order;
        valueHolder<arg1Type> arg1;
        valueHolder<arg2Type> arg2;
        valueHolder<arg3Type> arg3;
        valueHolder<arg4Type> arg4;
        valueHolder<arg5Type> arg5;
        valueHolder<arg6Type> arg6;
        valueHolder<arg7Type> arg7;
        valueHolder<arg8Type> arg8;
        valueHolder<arg9Type> arg9;
        valueHolder<arg10Type> arg10;
        valueHolder<arg11Type> arg11;
    };
    std::vector<timeS> allCalls;
public:
    call11Arg()
    {
        stims_base::registerCallXArg(this);
    }

    virtual ~call11Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type,  C>()
    {
    }
    virtual void PlayTick(_In_ UINT32 tick, _In_ UINT32 order)
    {
        for(UINT32 i=0; i<allCalls.size();i++)
        {
            if((allCalls[i].time==tick)&&(allCalls[i].order==order))
            {
                C::realFunction(allCalls[i].arg1, allCalls[i].arg2, allCalls[i].arg3, allCalls[i].arg4, allCalls[i].arg5, allCalls[i].arg6, allCalls[i].arg7, allCalls[i].arg8, allCalls[i].arg9, allCalls[i].arg10, allCalls[i].arg11);
            }
        }
    }

    call11Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, C>& SetTime(_In_ UINT32 time, _In_ UINT32 order)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_TIME_BEFORE_CALL, _T("using SetTime before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            allCalls[allCalls.size()-1].time=time;
            allCalls[allCalls.size()-1].order=order;
        }
        return *this;
    }

    call11Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type,  C>& operator()(arg1Type arg1,arg2Type arg2,arg3Type arg3,arg4Type arg4,arg5Type arg5,arg6Type arg6,arg7Type arg7,arg8Type arg8,arg9Type arg9,arg10Type arg10,arg11Type arg11)
    {
        timeS s(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
        allCalls.push_back(s); /*time is updated "later" by chaining*/
        return *this;
    }

    call11Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type,  C>& setArraySize(_In_ UINT32 parameter, _In_ size_t nElements)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_ARRAY_SIZE_BEFORE_CALL, _T("using setArraySize before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            timeS& s = allCalls[allCalls.size()-1]; /*get the last element*/
            switch(parameter)
            {
                case 1:
                {
                    s.arg1.setArraySize(nElements);
                    break;
                }
                case 2:
                {
                    s.arg2.setArraySize(nElements);
                    break;
                }
                case 3:
                {
                    s.arg3.setArraySize(nElements);
                    break;
                }
                case 4:
                {
                    s.arg4.setArraySize(nElements);
                    break;
                }
                case 5:
                {
                    s.arg5.setArraySize(nElements);
                    break;
                }
                case 6:
                {
                    s.arg6.setArraySize(nElements);
                    break;
                }
                case 7:
                {
                    s.arg7.setArraySize(nElements);
                    break;
                }
                case 8:
                {
                    s.arg8.setArraySize(nElements);
                    break;
                }
                case 9:
                {
                    s.arg9.setArraySize(nElements);
                    break;
                }
                case 10:
                {
                    s.arg10.setArraySize(nElements);
                    break;
                }
                case 11:
                {
                    s.arg11.setArraySize(nElements);
                    break;
                }
                default:
                {
                    ASSERT_FAIL(_T("there are no parameters so big"));
                }
            }
            return *this;
        }
    }
};

template<typename resultType,typename arg1Type, typename arg2Type, typename arg3Type, typename arg4Type, typename arg5Type, typename arg6Type, typename arg7Type, typename arg8Type, typename arg9Type, typename arg10Type, typename arg11Type, typename arg12Type, class C>class call12Arg : public canPlay
{
private:
    class timeS
    {
    public:
        timeS(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value, arg8Type arg8Value, arg9Type arg9Value, arg10Type arg10Value, arg11Type arg11Value, arg12Type arg12Value):
        time(0), order(0), arg1(arg1Value), arg2(arg2Value), arg3(arg3Value), arg4(arg4Value), arg5(arg5Value), arg6(arg6Value), arg7(arg7Value), arg8(arg8Value), arg9(arg9Value), arg10(arg10Value), arg11(arg11Value), arg12(arg12Value)
        {
        }
        UINT32 time;
        UINT32 order;
        valueHolder<arg1Type> arg1;
        valueHolder<arg2Type> arg2;
        valueHolder<arg3Type> arg3;
        valueHolder<arg4Type> arg4;
        valueHolder<arg5Type> arg5;
        valueHolder<arg6Type> arg6;
        valueHolder<arg7Type> arg7;
        valueHolder<arg8Type> arg8;
        valueHolder<arg9Type> arg9;
        valueHolder<arg10Type> arg10;
        valueHolder<arg11Type> arg11;
        valueHolder<arg12Type> arg12;
    };
    std::vector<timeS> allCalls;
public:
    call12Arg()
    {
        stims_base::registerCallXArg(this);
    }

    virtual ~call12Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type,  C>()
    {
    }
    virtual void PlayTick(_In_ UINT32 tick, _In_ UINT32 order)
    {
        for(UINT32 i=0; i<allCalls.size();i++)
        {
            if((allCalls[i].time==tick)&&(allCalls[i].order==order))
            {
                C::realFunction(allCalls[i].arg1, allCalls[i].arg2, allCalls[i].arg3, allCalls[i].arg4, allCalls[i].arg5, allCalls[i].arg6, allCalls[i].arg7, allCalls[i].arg8, allCalls[i].arg9, allCalls[i].arg10, allCalls[i].arg11, allCalls[i].arg12);
            }
        }
    }

    call12Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type, C>& SetTime(_In_ UINT32 time, _In_ UINT32 order)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_TIME_BEFORE_CALL, _T("using SetTime before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            allCalls[allCalls.size()-1].time=time;
            allCalls[allCalls.size()-1].order=order;
        }
        return *this;
    }

    call12Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type,  C>& operator()(arg1Type arg1,arg2Type arg2,arg3Type arg3,arg4Type arg4,arg5Type arg5,arg6Type arg6,arg7Type arg7,arg8Type arg8,arg9Type arg9,arg10Type arg10,arg11Type arg11,arg12Type arg12)
    {
        timeS s(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12);
        allCalls.push_back(s); /*time is updated "later" by chaining*/
        return *this;
    }

    call12Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type,  C>& setArraySize(_In_ UINT32 parameter, _In_ size_t nElements)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_ARRAY_SIZE_BEFORE_CALL, _T("using setArraySize before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            timeS& s = allCalls[allCalls.size()-1]; /*get the last element*/
            switch(parameter)
            {
                case 1:
                {
                    s.arg1.setArraySize(nElements);
                    break;
                }
                case 2:
                {
                    s.arg2.setArraySize(nElements);
                    break;
                }
                case 3:
                {
                    s.arg3.setArraySize(nElements);
                    break;
                }
                case 4:
                {
                    s.arg4.setArraySize(nElements);
                    break;
                }
                case 5:
                {
                    s.arg5.setArraySize(nElements);
                    break;
                }
                case 6:
                {
                    s.arg6.setArraySize(nElements);
                    break;
                }
                case 7:
                {
                    s.arg7.setArraySize(nElements);
                    break;
                }
                case 8:
                {
                    s.arg8.setArraySize(nElements);
                    break;
                }
                case 9:
                {
                    s.arg9.setArraySize(nElements);
                    break;
                }
                case 10:
                {
                    s.arg10.setArraySize(nElements);
                    break;
                }
                case 11:
                {
                    s.arg11.setArraySize(nElements);
                    break;
                }
                case 12:
                {
                    s.arg12.setArraySize(nElements);
                    break;
                }
                default:
                {
                    ASSERT_FAIL(_T("there are no parameters so big"));
                }
            }
            return *this;
        }
    }
};

template<typename resultType,typename arg1Type, typename arg2Type, typename arg3Type, typename arg4Type, typename arg5Type, typename arg6Type, typename arg7Type, typename arg8Type, typename arg9Type, typename arg10Type, typename arg11Type, typename arg12Type, typename arg13Type, class C>class call13Arg : public canPlay
{
private:
    class timeS
    {
    public:
        timeS(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value, arg8Type arg8Value, arg9Type arg9Value, arg10Type arg10Value, arg11Type arg11Value, arg12Type arg12Value, arg13Type arg13Value):
        time(0), order(0), arg1(arg1Value), arg2(arg2Value), arg3(arg3Value), arg4(arg4Value), arg5(arg5Value), arg6(arg6Value), arg7(arg7Value), arg8(arg8Value), arg9(arg9Value), arg10(arg10Value), arg11(arg11Value), arg12(arg12Value), arg13(arg13Value)
        {
        }
        UINT32 time;
        UINT32 order;
        valueHolder<arg1Type> arg1;
        valueHolder<arg2Type> arg2;
        valueHolder<arg3Type> arg3;
        valueHolder<arg4Type> arg4;
        valueHolder<arg5Type> arg5;
        valueHolder<arg6Type> arg6;
        valueHolder<arg7Type> arg7;
        valueHolder<arg8Type> arg8;
        valueHolder<arg9Type> arg9;
        valueHolder<arg10Type> arg10;
        valueHolder<arg11Type> arg11;
        valueHolder<arg12Type> arg12;
        valueHolder<arg13Type> arg13;
    };
    std::vector<timeS> allCalls;
public:
    call13Arg()
    {
        stims_base::registerCallXArg(this);
    }

    virtual ~call13Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type, arg13Type,  C>()
    {
    }
    virtual void PlayTick(_In_ UINT32 tick, _In_ UINT32 order)
    {
        for(UINT32 i=0; i<allCalls.size();i++)
        {
            if((allCalls[i].time==tick)&&(allCalls[i].order==order))
            {
                C::realFunction(allCalls[i].arg1, allCalls[i].arg2, allCalls[i].arg3, allCalls[i].arg4, allCalls[i].arg5, allCalls[i].arg6, allCalls[i].arg7, allCalls[i].arg8, allCalls[i].arg9, allCalls[i].arg10, allCalls[i].arg11, allCalls[i].arg12, allCalls[i].arg13);
            }
        }
    }

    call13Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type, arg13Type, C>& SetTime(_In_ UINT32 time, _In_ UINT32 order)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_TIME_BEFORE_CALL, _T("using SetTime before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            allCalls[allCalls.size()-1].time=time;
            allCalls[allCalls.size()-1].order=order;
        }
        return *this;
    }

    call13Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type, arg13Type,  C>& operator()(arg1Type arg1,arg2Type arg2,arg3Type arg3,arg4Type arg4,arg5Type arg5,arg6Type arg6,arg7Type arg7,arg8Type arg8,arg9Type arg9,arg10Type arg10,arg11Type arg11,arg12Type arg12,arg13Type arg13)
    {
        timeS s(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13);
        allCalls.push_back(s); /*time is updated "later" by chaining*/
        return *this;
    }

    call13Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type, arg13Type,  C>& setArraySize(_In_ UINT32 parameter, _In_ size_t nElements)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_ARRAY_SIZE_BEFORE_CALL, _T("using setArraySize before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            timeS& s = allCalls[allCalls.size()-1]; /*get the last element*/
            switch(parameter)
            {
                case 1:
                {
                    s.arg1.setArraySize(nElements);
                    break;
                }
                case 2:
                {
                    s.arg2.setArraySize(nElements);
                    break;
                }
                case 3:
                {
                    s.arg3.setArraySize(nElements);
                    break;
                }
                case 4:
                {
                    s.arg4.setArraySize(nElements);
                    break;
                }
                case 5:
                {
                    s.arg5.setArraySize(nElements);
                    break;
                }
                case 6:
                {
                    s.arg6.setArraySize(nElements);
                    break;
                }
                case 7:
                {
                    s.arg7.setArraySize(nElements);
                    break;
                }
                case 8:
                {
                    s.arg8.setArraySize(nElements);
                    break;
                }
                case 9:
                {
                    s.arg9.setArraySize(nElements);
                    break;
                }
                case 10:
                {
                    s.arg10.setArraySize(nElements);
                    break;
                }
                case 11:
                {
                    s.arg11.setArraySize(nElements);
                    break;
                }
                case 12:
                {
                    s.arg12.setArraySize(nElements);
                    break;
                }
                case 13:
                {
                    s.arg13.setArraySize(nElements);
                    break;
                }
                default:
                {
                    ASSERT_FAIL(_T("there are no parameters so big"));
                }
            }
            return *this;
        }
    }
};

template<typename resultType,typename arg1Type, typename arg2Type, typename arg3Type, typename arg4Type, typename arg5Type, typename arg6Type, typename arg7Type, typename arg8Type, typename arg9Type, typename arg10Type, typename arg11Type, typename arg12Type, typename arg13Type, typename arg14Type, class C>class call14Arg : public canPlay
{
private:
    class timeS
    {
    public:
        timeS(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value, arg8Type arg8Value, arg9Type arg9Value, arg10Type arg10Value, arg11Type arg11Value, arg12Type arg12Value, arg13Type arg13Value, arg14Type arg14Value):
        time(0), order(0), arg1(arg1Value), arg2(arg2Value), arg3(arg3Value), arg4(arg4Value), arg5(arg5Value), arg6(arg6Value), arg7(arg7Value), arg8(arg8Value), arg9(arg9Value), arg10(arg10Value), arg11(arg11Value), arg12(arg12Value), arg13(arg13Value), arg14(arg14Value)
        {
        }
        UINT32 time;
        UINT32 order;
        valueHolder<arg1Type> arg1;
        valueHolder<arg2Type> arg2;
        valueHolder<arg3Type> arg3;
        valueHolder<arg4Type> arg4;
        valueHolder<arg5Type> arg5;
        valueHolder<arg6Type> arg6;
        valueHolder<arg7Type> arg7;
        valueHolder<arg8Type> arg8;
        valueHolder<arg9Type> arg9;
        valueHolder<arg10Type> arg10;
        valueHolder<arg11Type> arg11;
        valueHolder<arg12Type> arg12;
        valueHolder<arg13Type> arg13;
        valueHolder<arg14Type> arg14;
    };
    std::vector<timeS> allCalls;
public:
    call14Arg()
    {
        stims_base::registerCallXArg(this);
    }

    virtual ~call14Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type, arg13Type, arg14Type,  C>()
    {
    }
    virtual void PlayTick(_In_ UINT32 tick, _In_ UINT32 order)
    {
        for(UINT32 i=0; i<allCalls.size();i++)
        {
            if((allCalls[i].time==tick)&&(allCalls[i].order==order))
            {
                C::realFunction(allCalls[i].arg1, allCalls[i].arg2, allCalls[i].arg3, allCalls[i].arg4, allCalls[i].arg5, allCalls[i].arg6, allCalls[i].arg7, allCalls[i].arg8, allCalls[i].arg9, allCalls[i].arg10, allCalls[i].arg11, allCalls[i].arg12, allCalls[i].arg13, allCalls[i].arg14);
            }
        }
    }

    call14Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type, arg13Type, arg14Type, C>& SetTime(_In_ UINT32 time, _In_ UINT32 order)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_TIME_BEFORE_CALL, _T("using SetTime before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            allCalls[allCalls.size()-1].time=time;
            allCalls[allCalls.size()-1].order=order;
        }
        return *this;
    }

    call14Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type, arg13Type, arg14Type,  C>& operator()(arg1Type arg1,arg2Type arg2,arg3Type arg3,arg4Type arg4,arg5Type arg5,arg6Type arg6,arg7Type arg7,arg8Type arg8,arg9Type arg9,arg10Type arg10,arg11Type arg11,arg12Type arg12,arg13Type arg13,arg14Type arg14)
    {
        timeS s(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
        allCalls.push_back(s); /*time is updated "later" by chaining*/
        return *this;
    }

    call14Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type, arg13Type, arg14Type,  C>& setArraySize(_In_ UINT32 parameter, _In_ size_t nElements)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_ARRAY_SIZE_BEFORE_CALL, _T("using setArraySize before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            timeS& s = allCalls[allCalls.size()-1]; /*get the last element*/
            switch(parameter)
            {
                case 1:
                {
                    s.arg1.setArraySize(nElements);
                    break;
                }
                case 2:
                {
                    s.arg2.setArraySize(nElements);
                    break;
                }
                case 3:
                {
                    s.arg3.setArraySize(nElements);
                    break;
                }
                case 4:
                {
                    s.arg4.setArraySize(nElements);
                    break;
                }
                case 5:
                {
                    s.arg5.setArraySize(nElements);
                    break;
                }
                case 6:
                {
                    s.arg6.setArraySize(nElements);
                    break;
                }
                case 7:
                {
                    s.arg7.setArraySize(nElements);
                    break;
                }
                case 8:
                {
                    s.arg8.setArraySize(nElements);
                    break;
                }
                case 9:
                {
                    s.arg9.setArraySize(nElements);
                    break;
                }
                case 10:
                {
                    s.arg10.setArraySize(nElements);
                    break;
                }
                case 11:
                {
                    s.arg11.setArraySize(nElements);
                    break;
                }
                case 12:
                {
                    s.arg12.setArraySize(nElements);
                    break;
                }
                case 13:
                {
                    s.arg13.setArraySize(nElements);
                    break;
                }
                case 14:
                {
                    s.arg14.setArraySize(nElements);
                    break;
                }
                default:
                {
                    ASSERT_FAIL(_T("there are no parameters so big"));
                }
            }
            return *this;
        }
    }
};

template<typename resultType,typename arg1Type, typename arg2Type, typename arg3Type, typename arg4Type, typename arg5Type, typename arg6Type, typename arg7Type, typename arg8Type, typename arg9Type, typename arg10Type, typename arg11Type, typename arg12Type, typename arg13Type, typename arg14Type, typename arg15Type, class C>class call15Arg : public canPlay
{
private:
    class timeS
    {
    public:
        timeS(arg1Type arg1Value, arg2Type arg2Value, arg3Type arg3Value, arg4Type arg4Value, arg5Type arg5Value, arg6Type arg6Value, arg7Type arg7Value, arg8Type arg8Value, arg9Type arg9Value, arg10Type arg10Value, arg11Type arg11Value, arg12Type arg12Value, arg13Type arg13Value, arg14Type arg14Value, arg15Type arg15Value):
        time(0), order(0), arg1(arg1Value), arg2(arg2Value), arg3(arg3Value), arg4(arg4Value), arg5(arg5Value), arg6(arg6Value), arg7(arg7Value), arg8(arg8Value), arg9(arg9Value), arg10(arg10Value), arg11(arg11Value), arg12(arg12Value), arg13(arg13Value), arg14(arg14Value), arg15(arg15Value)
        {
        }
        UINT32 time;
        UINT32 order;
        valueHolder<arg1Type> arg1;
        valueHolder<arg2Type> arg2;
        valueHolder<arg3Type> arg3;
        valueHolder<arg4Type> arg4;
        valueHolder<arg5Type> arg5;
        valueHolder<arg6Type> arg6;
        valueHolder<arg7Type> arg7;
        valueHolder<arg8Type> arg8;
        valueHolder<arg9Type> arg9;
        valueHolder<arg10Type> arg10;
        valueHolder<arg11Type> arg11;
        valueHolder<arg12Type> arg12;
        valueHolder<arg13Type> arg13;
        valueHolder<arg14Type> arg14;
        valueHolder<arg15Type> arg15;
    };
    std::vector<timeS> allCalls;
public:
    call15Arg()
    {
        stims_base::registerCallXArg(this);
    }

    virtual ~call15Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type, arg13Type, arg14Type, arg15Type,  C>()
    {
    }
    virtual void PlayTick(_In_ UINT32 tick, _In_ UINT32 order)
    {
        for(UINT32 i=0; i<allCalls.size();i++)
        {
            if((allCalls[i].time==tick)&&(allCalls[i].order==order))
            {
                C::realFunction(allCalls[i].arg1, allCalls[i].arg2, allCalls[i].arg3, allCalls[i].arg4, allCalls[i].arg5, allCalls[i].arg6, allCalls[i].arg7, allCalls[i].arg8, allCalls[i].arg9, allCalls[i].arg10, allCalls[i].arg11, allCalls[i].arg12, allCalls[i].arg13, allCalls[i].arg14, allCalls[i].arg15);
            }
        }
    }

    call15Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type, arg13Type, arg14Type, arg15Type, C>& SetTime(_In_ UINT32 time, _In_ UINT32 order)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_TIME_BEFORE_CALL, _T("using SetTime before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            allCalls[allCalls.size()-1].time=time;
            allCalls[allCalls.size()-1].order=order;
        }
        return *this;
    }

    call15Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type, arg13Type, arg14Type, arg15Type,  C>& operator()(arg1Type arg1,arg2Type arg2,arg3Type arg3,arg4Type arg4,arg5Type arg5,arg6Type arg6,arg7Type arg7,arg8Type arg8,arg9Type arg9,arg10Type arg10,arg11Type arg11,arg12Type arg12,arg13Type arg13,arg14Type arg14,arg15Type arg15)
    {
        timeS s(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15);
        allCalls.push_back(s); /*time is updated "later" by chaining*/
        return *this;
    }

    call15Arg<resultType, arg1Type, arg2Type, arg3Type, arg4Type, arg5Type, arg6Type, arg7Type, arg8Type, arg9Type, arg10Type, arg11Type, arg12Type, arg13Type, arg14Type, arg15Type,  C>& setArraySize(_In_ UINT32 parameter, _In_ size_t nElements)
    {
        if(allCalls.size()==0)
        {
            throw CMicroMockException(MICROMOCK_EXCEPTION_SET_ARRAY_SIZE_BEFORE_CALL, _T("using setArraySize before the call has been defined usually indicates an error in test code"));
        }
        else
        {
            timeS& s = allCalls[allCalls.size()-1]; /*get the last element*/
            switch(parameter)
            {
                case 1:
                {
                    s.arg1.setArraySize(nElements);
                    break;
                }
                case 2:
                {
                    s.arg2.setArraySize(nElements);
                    break;
                }
                case 3:
                {
                    s.arg3.setArraySize(nElements);
                    break;
                }
                case 4:
                {
                    s.arg4.setArraySize(nElements);
                    break;
                }
                case 5:
                {
                    s.arg5.setArraySize(nElements);
                    break;
                }
                case 6:
                {
                    s.arg6.setArraySize(nElements);
                    break;
                }
                case 7:
                {
                    s.arg7.setArraySize(nElements);
                    break;
                }
                case 8:
                {
                    s.arg8.setArraySize(nElements);
                    break;
                }
                case 9:
                {
                    s.arg9.setArraySize(nElements);
                    break;
                }
                case 10:
                {
                    s.arg10.setArraySize(nElements);
                    break;
                }
                case 11:
                {
                    s.arg11.setArraySize(nElements);
                    break;
                }
                case 12:
                {
                    s.arg12.setArraySize(nElements);
                    break;
                }
                case 13:
                {
                    s.arg13.setArraySize(nElements);
                    break;
                }
                case 14:
                {
                    s.arg14.setArraySize(nElements);
                    break;
                }
                case 15:
                {
                    s.arg15.setArraySize(nElements);
                    break;
                }
                default:
                {
                    ASSERT_FAIL(_T("there are no parameters so big"));
                }
            }
            return *this;
        }
    }
};

#endif // TIMEDISCRETEMICROMOCKCALLMACROS_H

